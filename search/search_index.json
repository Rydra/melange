{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The spice must flow Melange is a python library/framework that abstracts a lot of the boilerplate that is usually required to implement a messaging infrastructure (commonly used to create distributed architectures and interact with microservices architectures). Out of the box Melange supports Amazon SQS + SNS, though the library is designed to be extensible, so that you can use it with your own messaging infrastructure, should you choose so. The interface this library offers is very clean and tries to tightly follow the best practices from Vaughn Vernon's book Implementing Domain-Driven Design as well as the recommended design patterns when dealing with messaging on distributed architectures. Installing pip install melange Documentation Full documentation is available at https://rydra.github.io/melange/ Examples The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service Why the name 'Melange' The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :) Project Links Docs: https://rydra.github.io/melange License MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"Melange"},{"location":"#installing","text":"pip install melange","title":"Installing"},{"location":"#documentation","text":"Full documentation is available at https://rydra.github.io/melange/","title":"Documentation"},{"location":"#examples","text":"The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service","title":"Examples"},{"location":"#why-the-name-melange","text":"The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :)","title":"Why the name 'Melange'"},{"location":"#project-links","text":"Docs: https://rydra.github.io/melange","title":"Project Links"},{"location":"#license","text":"MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"License"},{"location":"advanced-topics/","text":"Advanced Topics Registering the MessagingBackend globally To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . set_default_backend ( AWSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. Usage of the backend manager from melange.backends.backend_manager import BackendManager from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . set_default_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects. Message de-duplication Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a cache interface that you can supply to the ConsumerHandler (like a Redis cache ) that will control that no message is delivered twice to the same consumer. In Melange we provide a RedisCache class that you could use to perform this message deduplication. However we do not want to tie the library to any specific technology, so as long as you comply with the DeduplicationCache interface it will work just fine. The cache for message deduplication is completely optional, but on a production environment having some kind of cache to handle deduplication is encouraged. This is the DeduplicationCache specification: Source code in melange/infrastructure/cache.py class DeduplicationCache ( Protocol ): def store ( self , key : str , value : Any , expire : Optional [ int ] = None ) -> None : \"\"\" Stores a key into the cache Args: key: value: expire: expiration time in seconds \"\"\" raise NotImplementedError def get ( self , key : str ) -> Any : \"\"\" Retrieves the value stored under a key Args: key: the key to fetch in the cache Returns: The value stored under that key, or None \"\"\" raise NotImplementedError def __contains__ ( self , key : str ) -> bool : \"\"\" Checks whether a certain key is present in the store Args: key: the key to check Returns: `True` if the value is present, `False` otherwise. \"\"\" raise NotImplementedError __contains__ ( self , key ) special Checks whether a certain key is present in the store Parameters: Name Type Description Default key str the key to check required Returns: Type Description bool True if the value is present, False otherwise. Source code in melange/infrastructure/cache.py def __contains__ ( self , key : str ) -> bool : \"\"\" Checks whether a certain key is present in the store Args: key: the key to check Returns: `True` if the value is present, `False` otherwise. \"\"\" raise NotImplementedError get ( self , key ) Retrieves the value stored under a key Parameters: Name Type Description Default key str the key to fetch in the cache required Returns: Type Description Any The value stored under that key, or None Source code in melange/infrastructure/cache.py def get ( self , key : str ) -> Any : \"\"\" Retrieves the value stored under a key Args: key: the key to fetch in the cache Returns: The value stored under that key, or None \"\"\" raise NotImplementedError store ( self , key , value , expire = None ) Stores a key into the cache Parameters: Name Type Description Default key str required value Any required expire Optional[int] expiration time in seconds None Source code in melange/infrastructure/cache.py def store ( self , key : str , value : Any , expire : Optional [ int ] = None ) -> None : \"\"\" Stores a key into the cache Args: key: value: expire: expiration time in seconds \"\"\" raise NotImplementedError","title":"Advanced topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#registering-the-messagingbackend-globally","text":"To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . set_default_backend ( AWSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. Usage of the backend manager from melange.backends.backend_manager import BackendManager from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . set_default_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects.","title":"Registering the MessagingBackend globally"},{"location":"advanced-topics/#message-de-duplication","text":"Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a cache interface that you can supply to the ConsumerHandler (like a Redis cache ) that will control that no message is delivered twice to the same consumer. In Melange we provide a RedisCache class that you could use to perform this message deduplication. However we do not want to tie the library to any specific technology, so as long as you comply with the DeduplicationCache interface it will work just fine. The cache for message deduplication is completely optional, but on a production environment having some kind of cache to handle deduplication is encouraged. This is the DeduplicationCache specification: Source code in melange/infrastructure/cache.py class DeduplicationCache ( Protocol ): def store ( self , key : str , value : Any , expire : Optional [ int ] = None ) -> None : \"\"\" Stores a key into the cache Args: key: value: expire: expiration time in seconds \"\"\" raise NotImplementedError def get ( self , key : str ) -> Any : \"\"\" Retrieves the value stored under a key Args: key: the key to fetch in the cache Returns: The value stored under that key, or None \"\"\" raise NotImplementedError def __contains__ ( self , key : str ) -> bool : \"\"\" Checks whether a certain key is present in the store Args: key: the key to check Returns: `True` if the value is present, `False` otherwise. \"\"\" raise NotImplementedError","title":"Message de-duplication"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.__contains__","text":"Checks whether a certain key is present in the store Parameters: Name Type Description Default key str the key to check required Returns: Type Description bool True if the value is present, False otherwise. Source code in melange/infrastructure/cache.py def __contains__ ( self , key : str ) -> bool : \"\"\" Checks whether a certain key is present in the store Args: key: the key to check Returns: `True` if the value is present, `False` otherwise. \"\"\" raise NotImplementedError","title":"__contains__()"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.get","text":"Retrieves the value stored under a key Parameters: Name Type Description Default key str the key to fetch in the cache required Returns: Type Description Any The value stored under that key, or None Source code in melange/infrastructure/cache.py def get ( self , key : str ) -> Any : \"\"\" Retrieves the value stored under a key Args: key: the key to fetch in the cache Returns: The value stored under that key, or None \"\"\" raise NotImplementedError","title":"get()"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.store","text":"Stores a key into the cache Parameters: Name Type Description Default key str required value Any required expire Optional[int] expiration time in seconds None Source code in melange/infrastructure/cache.py def store ( self , key : str , value : Any , expire : Optional [ int ] = None ) -> None : \"\"\" Stores a key into the cache Args: key: value: expire: expiration time in seconds \"\"\" raise NotImplementedError","title":"store()"},{"location":"behind-scenes/","text":"Behind the scenes How are messages serialized Messages, when serialized, they have the shape of a string. Some serializing formats might not require anything more that the message itself (like pickle). The message itself contains headers of some kind that tells deserializers how they have to deserialize that message (assuming you already know you always have to use that specific serializer). Other formats (like protobuf) require some kind of specification that tells the consumers how the message needs to be deserialized. This is why manifests exist and are necessary. A manifest tells the aplicacion which shape (manifestation) an array of bytes or a string had. This way we can appropriately choose the serializer that is able to properly deserialize the message. Imagine we want to serialize an object with a serializer that performs encryption as well: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ If we just sent that string to an outsider, how does it know that is a ProductCreated which has been serialized with a special serializer? However, with the aid of the manifest, we can give some clue to the deserializer on how that message was serialized: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ manifest = serializer . manifest ( event ) # manifest could be something like `mycryptoserializer:sha1:ProductCreated` That way we tell the consumer who has to deserialize the message that the message was serialized with the MyCryptographicSerializer , with a SHA1 algorithm, and that it is a ProductCreated event. The publishers, when sending the message, they send the manifest as well as the serialized message to provide the consumers with this valuable information. The manifest could be sent through the means of metadata (if your messaging infrastructure supports it) or through any other means that could be retrieved by the consumer.","title":"Behind the scenes"},{"location":"behind-scenes/#behind-the-scenes","text":"","title":"Behind the scenes"},{"location":"behind-scenes/#how-are-messages-serialized","text":"Messages, when serialized, they have the shape of a string. Some serializing formats might not require anything more that the message itself (like pickle). The message itself contains headers of some kind that tells deserializers how they have to deserialize that message (assuming you already know you always have to use that specific serializer). Other formats (like protobuf) require some kind of specification that tells the consumers how the message needs to be deserialized. This is why manifests exist and are necessary. A manifest tells the aplicacion which shape (manifestation) an array of bytes or a string had. This way we can appropriately choose the serializer that is able to properly deserialize the message. Imagine we want to serialize an object with a serializer that performs encryption as well: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ If we just sent that string to an outsider, how does it know that is a ProductCreated which has been serialized with a special serializer? However, with the aid of the manifest, we can give some clue to the deserializer on how that message was serialized: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ manifest = serializer . manifest ( event ) # manifest could be something like `mycryptoserializer:sha1:ProductCreated` That way we tell the consumer who has to deserialize the message that the message was serialized with the MyCryptographicSerializer , with a SHA1 algorithm, and that it is a ProductCreated event. The publishers, when sending the message, they send the manifest as well as the serialized message to provide the consumers with this valuable information. The manifest could be sent through the means of metadata (if your messaging infrastructure supports it) or through any other means that could be retrieved by the consumer.","title":"How are messages serialized"},{"location":"examples/","text":"Examples Here are listed some relevant examples that you can find in the source code of Melange, alongside some explanation. The MessagingBackend used for all the examples is the LocalSQSBackend , though you could use your own. Personally what I do is to spin up a docker-compose process and then run the examples. Payment Service Example source This is the Melange/python version of the Order/Payment service that is being implemented in the video series SAGA Choreography Implementation . The example corresponds to a payment service that listens to a queue that receives events from an order service (which might come from another external service) and then those events are consumed to perform more logic. How to run the example: Run make run-example-app . This will start the consumer. On another terminal, run make run-example-triggerer reference=\"SOMEREFNUMBER\" Each time you run the triggerer, you should see a message like Order SOMEREFNUMBER paid successfully pop, meaning that the message was received successfully. SAGA Choreography Example source In this example we will see one powerful usage of melange in the form of a mix of saga orchestration/choreography. We will run a SAGA service that will manage the entire order processing service, and deliver the messages to the appropriate services to run what could be a fully distributed application. How to run the example. Run make run-example-app to start up the consumer for the payment service. Run make run-example-saga to start up the consumer for the saga orchestrator. On another terminal, run make run-example-saga-triggerer reference=\"SOMEREFNUMBER\" What you should see once you run the triggerer is, on the payment service consumer screen, the confirmation that the order was paid and immediately afterwards, on the saga orchestrator screen, the message that the order was paid and marked as complete. Congratulations on running your first web of microservices, connected by a messaging broker with passing messages!","title":"Examples"},{"location":"examples/#examples","text":"Here are listed some relevant examples that you can find in the source code of Melange, alongside some explanation. The MessagingBackend used for all the examples is the LocalSQSBackend , though you could use your own. Personally what I do is to spin up a docker-compose process and then run the examples.","title":"Examples"},{"location":"examples/#payment-service","text":"Example source This is the Melange/python version of the Order/Payment service that is being implemented in the video series SAGA Choreography Implementation . The example corresponds to a payment service that listens to a queue that receives events from an order service (which might come from another external service) and then those events are consumed to perform more logic. How to run the example: Run make run-example-app . This will start the consumer. On another terminal, run make run-example-triggerer reference=\"SOMEREFNUMBER\" Each time you run the triggerer, you should see a message like Order SOMEREFNUMBER paid successfully pop, meaning that the message was received successfully.","title":"Payment Service"},{"location":"examples/#saga-choreography","text":"Example source In this example we will see one powerful usage of melange in the form of a mix of saga orchestration/choreography. We will run a SAGA service that will manage the entire order processing service, and deliver the messages to the appropriate services to run what could be a fully distributed application. How to run the example. Run make run-example-app to start up the consumer for the payment service. Run make run-example-saga to start up the consumer for the saga orchestrator. On another terminal, run make run-example-saga-triggerer reference=\"SOMEREFNUMBER\" What you should see once you run the triggerer is, on the payment service consumer screen, the confirmation that the order was paid and immediately afterwards, on the saga orchestrator screen, the message that the order was paid and marked as complete. Congratulations on running your first web of microservices, connected by a messaging broker with passing messages!","title":"SAGA Choreography"},{"location":"factory/","text":"Factory Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform. Creating a queue Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" ) Creating a topic Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.sqs.sqs_backend import AWSBackend from melange.backends.factory import MessagingBackendFactory backend = AWSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" ) Creating a queue and subscribing it to several topics You could create a queue and immediately subscribe it to a number of topics: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , [ \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" ], dead_letter_queue_name = \"payment-updates.fifo\" ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Factory"},{"location":"factory/#factory","text":"Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform.","title":"Factory"},{"location":"factory/#creating-a-queue","text":"Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" )","title":"Creating a queue"},{"location":"factory/#creating-a-topic","text":"Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.sqs.sqs_backend import AWSBackend from melange.backends.factory import MessagingBackendFactory backend = AWSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" )","title":"Creating a topic"},{"location":"factory/#creating-a-queue-and-subscribing-it-to-several-topics","text":"You could create a queue and immediately subscribe it to a number of topics: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , [ \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" ], dead_letter_queue_name = \"payment-updates.fifo\" ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Creating a queue and subscribing it to several topics"},{"location":"mixed-bag/","text":"Mixed bag of ideas Interesting links and articles Effective aggregate design by Vaughn Vernon Domain Events - Salvation by Udi Dahan Test structure in python : I really liked this article, it inspired me to restructure Melange a bit.","title":"Mixed bag of ideas"},{"location":"mixed-bag/#mixed-bag-of-ideas","text":"","title":"Mixed bag of ideas"},{"location":"mixed-bag/#interesting-links-and-articles","text":"Effective aggregate design by Vaughn Vernon Domain Events - Salvation by Udi Dahan Test structure in python : I really liked this article, it inspired me to restructure Melange a bit.","title":"Interesting links and articles"},{"location":"roadmap/","text":"Roadmap Multiple serializers Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept . Kombu integration Maybe The Messaging Backends could be entirely replaced with Kombu, since kombu already offers an abstraction layer over several messaging brokers. Undergo some kind of proof of concept to see if such a thing is possible and how. Kafka integration Kafka is a powerful messaging broker technology that covers lots of features and functionalities that could provide some ideas to the current features that melange provides.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#multiple-serializers","text":"Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept .","title":"Multiple serializers"},{"location":"roadmap/#kombu-integration","text":"Maybe The Messaging Backends could be entirely replaced with Kombu, since kombu already offers an abstraction layer over several messaging brokers. Undergo some kind of proof of concept to see if such a thing is possible and how.","title":"Kombu integration"},{"location":"roadmap/#kafka-integration","text":"Kafka is a powerful messaging broker technology that covers lots of features and functionalities that could provide some ideas to the current features that melange provides.","title":"Kafka integration"},{"location":"testing/","text":"Testing Any developer worth its salt does some kind of testing over the code they develop. However, testing software that spans several processes/threads (like when you do pub/sub over a queue/topic) can be a daunting task. Melange offers several utilities to help you test your publishers and consumers (or just making everything synchronous inside the context of the test for the sake of simplicity). Here some examples are presented on how you could potentially use the library in your tests. Asynchronous testing with threads Follow the next steps whenever you need to have one or more consumers running on the background of your test: Make sure to create (or ensure that they exist at least) the queues and topics where the message exchange happens. Start the consumer loop in a separate thread, and make sure the thread is stopped upon termination of the test. Call your code that invokes the publishing methods, and have probes in place that poll the environment to check whether the consumers have done their work or not before doing any kind of assertion that requires of the consumers' results. Bonus: After the test is finished, delete the queue/topic to keep the environment clean. Full Example: Asynchronous testing with probes and threads import os import threading from dataclasses import dataclass from typing import Dict , Optional import polling from hamcrest import * from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import Consumer from melange.message_dispatcher import SimpleMessageDispatcher from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer from tests.probe import Probe class StateProbe ( Probe ): def __init__ ( self , state : \"State\" ) -> None : self . state = state def sample ( self ) -> None : pass def can_be_measured ( self ) -> bool : self . sample () return self . state . value_set is not None def wait ( self ) -> None : try : polling . poll ( self . can_be_measured , 1 , timeout = 60 ) except polling . TimeoutException as e : raise Exception ( \"Timeout!\" ) from e @dataclass class State : value_set : Optional [ int ] = None def test_async_consumer ( request ): serializer = PickleSerializer () # We'll use the ElasticMQ as backend since it works like a real SQS queue backend = LocalSQSBackend ( host = os . environ . get ( \"SQSHOST\" ), port = os . environ . get ( \"SQSPORT\" ) ) queue_name = \"testqueue\" # Initialize the queue queue = MessagingBackendFactory ( backend ) . init_queue ( queue_name ) # Delete the queue upon finishing the execution of the test def teardown (): backend . delete_queue ( queue ) request . addfinalizer ( teardown ) # Create a consumer that, upon receiving a message, will set # the variable \"value set\" to later assert that this value # has, indeed, been set by the consumer that is running on another thread state = State () def set_state ( message : Dict ) -> None : state . value_set = message [ \"value\" ] consumer = Consumer ( on_message = set_state ) handler = SimpleMessageDispatcher ( consumer , serializer , backend = backend ) # Start the consumer loop thread to run the consumer loop in the background threading . Thread ( target = lambda : handler . consume_loop ( queue_name ), daemon = True ) . start () # Publish a message and... publisher = QueuePublisher ( serializer , backend ) publisher . publish ( queue_name , { \"value\" : 1 }) # ...wait until the value is set probe = StateProbe ( state ) probe . wait () assert_that ( state . value_set , is_ ( 1 )) This kind of test has the advantage of being very explicit in the sense that it expresses, through the probe, that this test has some asynchronous processing in the background, and waits for it. It's quite realistic as well, pub/sub is asynchronous in its nature and we work with it in this test. However the arrangement is complex. It's a trade-off between completeness and complexity that you have to embrace if you want to follow this route. TIP: Try to abstract away all this arrangement code from the main body of the test to keep it clean and clear, avoiding pollution. Testing frameworks have different techniques to abstract away arrangements (like pytest fixtures). Synchronous testing with the InMemoryMessagingBackend Another option is to use the bundled InMemoryMessagingBackend when instantiating your publishers and consumers. This will make the entirety of the test synchronous in respect to the message passing. Synchronous testing with the InMemoryMessagingBackend from melange.backends.testing import InMemoryMessagingBackend , link_synchronously from melange.consumers import Consumer from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer def test_inmemory_messaging_backend (): consumer_1 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } !\" )) consumer_2 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } 2!\" )) serializer = PickleSerializer () backend = InMemoryMessagingBackend () link_synchronously ( \"somequeue\" , [ consumer_1 , consumer_2 ], serializer , backend ) publisher = QueuePublisher ( PickleSerializer (), backend = backend ) publisher . publish ( \"somequeue\" , { \"message\" : \"Mary\" }) What the InMemoryMessagingBackend does, upon publish, is to store the serialized message in memory and forward it to the internal consumer dispatcher, so that the consumers can synchronously receive and process the message. The link_synchronously function is a helper which glues everything together. All the messages sent to the queue or topic with that name will be dispatched to those consumers (if the consumers accept that message).","title":"Testing"},{"location":"testing/#testing","text":"Any developer worth its salt does some kind of testing over the code they develop. However, testing software that spans several processes/threads (like when you do pub/sub over a queue/topic) can be a daunting task. Melange offers several utilities to help you test your publishers and consumers (or just making everything synchronous inside the context of the test for the sake of simplicity). Here some examples are presented on how you could potentially use the library in your tests.","title":"Testing"},{"location":"testing/#asynchronous-testing-with-threads","text":"Follow the next steps whenever you need to have one or more consumers running on the background of your test: Make sure to create (or ensure that they exist at least) the queues and topics where the message exchange happens. Start the consumer loop in a separate thread, and make sure the thread is stopped upon termination of the test. Call your code that invokes the publishing methods, and have probes in place that poll the environment to check whether the consumers have done their work or not before doing any kind of assertion that requires of the consumers' results. Bonus: After the test is finished, delete the queue/topic to keep the environment clean. Full Example: Asynchronous testing with probes and threads import os import threading from dataclasses import dataclass from typing import Dict , Optional import polling from hamcrest import * from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import Consumer from melange.message_dispatcher import SimpleMessageDispatcher from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer from tests.probe import Probe class StateProbe ( Probe ): def __init__ ( self , state : \"State\" ) -> None : self . state = state def sample ( self ) -> None : pass def can_be_measured ( self ) -> bool : self . sample () return self . state . value_set is not None def wait ( self ) -> None : try : polling . poll ( self . can_be_measured , 1 , timeout = 60 ) except polling . TimeoutException as e : raise Exception ( \"Timeout!\" ) from e @dataclass class State : value_set : Optional [ int ] = None def test_async_consumer ( request ): serializer = PickleSerializer () # We'll use the ElasticMQ as backend since it works like a real SQS queue backend = LocalSQSBackend ( host = os . environ . get ( \"SQSHOST\" ), port = os . environ . get ( \"SQSPORT\" ) ) queue_name = \"testqueue\" # Initialize the queue queue = MessagingBackendFactory ( backend ) . init_queue ( queue_name ) # Delete the queue upon finishing the execution of the test def teardown (): backend . delete_queue ( queue ) request . addfinalizer ( teardown ) # Create a consumer that, upon receiving a message, will set # the variable \"value set\" to later assert that this value # has, indeed, been set by the consumer that is running on another thread state = State () def set_state ( message : Dict ) -> None : state . value_set = message [ \"value\" ] consumer = Consumer ( on_message = set_state ) handler = SimpleMessageDispatcher ( consumer , serializer , backend = backend ) # Start the consumer loop thread to run the consumer loop in the background threading . Thread ( target = lambda : handler . consume_loop ( queue_name ), daemon = True ) . start () # Publish a message and... publisher = QueuePublisher ( serializer , backend ) publisher . publish ( queue_name , { \"value\" : 1 }) # ...wait until the value is set probe = StateProbe ( state ) probe . wait () assert_that ( state . value_set , is_ ( 1 )) This kind of test has the advantage of being very explicit in the sense that it expresses, through the probe, that this test has some asynchronous processing in the background, and waits for it. It's quite realistic as well, pub/sub is asynchronous in its nature and we work with it in this test. However the arrangement is complex. It's a trade-off between completeness and complexity that you have to embrace if you want to follow this route. TIP: Try to abstract away all this arrangement code from the main body of the test to keep it clean and clear, avoiding pollution. Testing frameworks have different techniques to abstract away arrangements (like pytest fixtures).","title":"Asynchronous testing with threads"},{"location":"testing/#synchronous-testing-with-the-inmemorymessagingbackend","text":"Another option is to use the bundled InMemoryMessagingBackend when instantiating your publishers and consumers. This will make the entirety of the test synchronous in respect to the message passing. Synchronous testing with the InMemoryMessagingBackend from melange.backends.testing import InMemoryMessagingBackend , link_synchronously from melange.consumers import Consumer from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer def test_inmemory_messaging_backend (): consumer_1 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } !\" )) consumer_2 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } 2!\" )) serializer = PickleSerializer () backend = InMemoryMessagingBackend () link_synchronously ( \"somequeue\" , [ consumer_1 , consumer_2 ], serializer , backend ) publisher = QueuePublisher ( PickleSerializer (), backend = backend ) publisher . publish ( \"somequeue\" , { \"message\" : \"Mary\" }) What the InMemoryMessagingBackend does, upon publish, is to store the serialized message in memory and forward it to the internal consumer dispatcher, so that the consumers can synchronously receive and process the message. The link_synchronously function is a helper which glues everything together. All the messages sent to the queue or topic with that name will be dispatched to those consumers (if the consumers accept that message).","title":"Synchronous testing with the InMemoryMessagingBackend"},{"location":"api-reference/consumers/","text":"Consumers Consumer A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a on_message callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the process and accepts methods. Source code in melange/consumers.py class Consumer : \"\"\" A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a `on_message` callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the `process` and `accepts` methods. \"\"\" def __init__ ( self , on_message : Optional [ Callable [[ Any ], None ]] = None ) -> None : self . _on_message = on_message def process ( self , message : Any , ** kwargs : Any ) -> None : \"\"\" Processes a message Args: message: the message data to process, already deserialied **kwargs: any other parameters the dispatcher sends upon processing \"\"\" if self . _on_message : self . _on_message ( message ) def accepts ( self , manifest : Any ) -> bool : \"\"\" Determines whether it is able to handle a message or not \"\"\" return True accepts ( self , manifest ) Determines whether it is able to handle a message or not Source code in melange/consumers.py def accepts ( self , manifest : Any ) -> bool : \"\"\" Determines whether it is able to handle a message or not \"\"\" return True process ( self , message , ** kwargs ) Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {} Source code in melange/consumers.py def process ( self , message : Any , ** kwargs : Any ) -> None : \"\"\" Processes a message Args: message: the message data to process, already deserialied **kwargs: any other parameters the dispatcher sends upon processing \"\"\" if self . _on_message : self . _on_message ( message ) SingleDispatchConsumer ( Consumer , SingleDispatch ) This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method Source code in melange/consumers.py class SingleDispatchConsumer ( Consumer , SingleDispatch ): \"\"\" This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method \"\"\" def process ( self , message : Any , ** kwargs : Any ) -> None : self . _process ( message ) @singledispatch def _process ( self , message : Any ) -> None : \"\"\"Event should be an instance of DomainEvent\"\"\" pass def accepts ( self , message : Any ) -> bool : accepted_types = filter ( lambda t : t is not object , self . _process . registry ) return any ( isinstance ( message , t ) for t in accepted_types ) accepts ( self , message ) Determines whether it is able to handle a message or not Source code in melange/consumers.py def accepts ( self , message : Any ) -> bool : accepted_types = filter ( lambda t : t is not object , self . _process . registry ) return any ( isinstance ( message , t ) for t in accepted_types ) process ( self , message , ** kwargs ) Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {} Source code in melange/consumers.py def process ( self , message : Any , ** kwargs : Any ) -> None : self . _process ( message )","title":"Consumers"},{"location":"api-reference/consumers/#consumers","text":"","title":"Consumers"},{"location":"api-reference/consumers/#melange.consumers.Consumer","text":"A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a on_message callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the process and accepts methods. Source code in melange/consumers.py class Consumer : \"\"\" A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a `on_message` callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the `process` and `accepts` methods. \"\"\" def __init__ ( self , on_message : Optional [ Callable [[ Any ], None ]] = None ) -> None : self . _on_message = on_message def process ( self , message : Any , ** kwargs : Any ) -> None : \"\"\" Processes a message Args: message: the message data to process, already deserialied **kwargs: any other parameters the dispatcher sends upon processing \"\"\" if self . _on_message : self . _on_message ( message ) def accepts ( self , manifest : Any ) -> bool : \"\"\" Determines whether it is able to handle a message or not \"\"\" return True","title":"Consumer"},{"location":"api-reference/consumers/#melange.consumers.Consumer.accepts","text":"Determines whether it is able to handle a message or not Source code in melange/consumers.py def accepts ( self , manifest : Any ) -> bool : \"\"\" Determines whether it is able to handle a message or not \"\"\" return True","title":"accepts()"},{"location":"api-reference/consumers/#melange.consumers.Consumer.process","text":"Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {} Source code in melange/consumers.py def process ( self , message : Any , ** kwargs : Any ) -> None : \"\"\" Processes a message Args: message: the message data to process, already deserialied **kwargs: any other parameters the dispatcher sends upon processing \"\"\" if self . _on_message : self . _on_message ( message )","title":"process()"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer","text":"This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method Source code in melange/consumers.py class SingleDispatchConsumer ( Consumer , SingleDispatch ): \"\"\" This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method \"\"\" def process ( self , message : Any , ** kwargs : Any ) -> None : self . _process ( message ) @singledispatch def _process ( self , message : Any ) -> None : \"\"\"Event should be an instance of DomainEvent\"\"\" pass def accepts ( self , message : Any ) -> bool : accepted_types = filter ( lambda t : t is not object , self . _process . registry ) return any ( isinstance ( message , t ) for t in accepted_types )","title":"SingleDispatchConsumer"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer.accepts","text":"Determines whether it is able to handle a message or not Source code in melange/consumers.py def accepts ( self , message : Any ) -> bool : accepted_types = filter ( lambda t : t is not object , self . _process . registry ) return any ( isinstance ( message , t ) for t in accepted_types )","title":"accepts()"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer.process","text":"Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {} Source code in melange/consumers.py def process ( self , message : Any , ** kwargs : Any ) -> None : self . _process ( message )","title":"process()"},{"location":"api-reference/factory/","text":"Messaging Backend Factory","title":"Factory"},{"location":"api-reference/factory/#messaging-backend-factory","text":"","title":"Messaging Backend Factory"},{"location":"api-reference/messaging-backends/","text":"Messaging Backends MessagingBackend Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError delete_queue ( self , queue ) Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError delete_topic ( self , topic ) Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/interfaces.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError BackendManager Source code in melange/backends/backend_manager.py class BackendManager ( metaclass = Singleton ): def __init__ ( self ) -> None : self . _backend : Optional [ MessagingBackend ] = None def set_default_backend ( self , backend : MessagingBackend , ) -> None : \"\"\" Sets the default backend Args: backend: \"\"\" if not isinstance ( backend , MessagingBackend ): raise Exception ( \"Invalid backend supplied\" ) self . _backend = backend def get_default_backend ( self ) -> MessagingBackend : \"\"\" Returns the current default backend \"\"\" if not self . _backend : raise Exception ( \"No backend is registered. Please call 'set_default_backend' prior to getting it\" ) return self . _backend get_default_backend ( self ) Returns the current default backend Source code in melange/backends/backend_manager.py def get_default_backend ( self ) -> MessagingBackend : \"\"\" Returns the current default backend \"\"\" if not self . _backend : raise Exception ( \"No backend is registered. Please call 'set_default_backend' prior to getting it\" ) return self . _backend set_default_backend ( self , backend ) Sets the default backend Parameters: Name Type Description Default backend MessagingBackend required Source code in melange/backends/backend_manager.py def set_default_backend ( self , backend : MessagingBackend , ) -> None : \"\"\" Sets the default backend Args: backend: \"\"\" if not isinstance ( backend , MessagingBackend ): raise Exception ( \"Invalid backend supplied\" ) self . _backend = backend AWSBackend ( BaseSQSBackend ) Backend to use with AWS Source code in melange/backends/sqs/sqs_backend.py class AWSBackend ( BaseSQSBackend ): \"\"\" Backend to use with AWS \"\"\" def __init__ ( self , ** kwargs : Any ) -> None : super () . __init__ ( ** kwargs ) BaseSQSBackend ( MessagingBackend ) Base class for SQS Backends Source code in melange/backends/sqs/sqs_backend.py class BaseSQSBackend ( MessagingBackend ): \"\"\" Base class for SQS Backends \"\"\" def __init__ ( self , ** kwargs : Any ) -> None : super () . __init__ () self . max_number_of_messages = kwargs . get ( \"max_number_of_messages\" , 10 ) self . visibility_timeout = kwargs . get ( \"visibility_timeout\" , 100 ) self . wait_time_seconds = kwargs . get ( \"wait_time_seconds\" , 10 ) self . extra_settings = kwargs . get ( \"extra_settings\" , {}) self . sns_settings = kwargs . get ( \"sns_settings\" , {}) def declare_topic ( self , topic_name : str ) -> TopicWrapper : sns = boto3 . resource ( \"sns\" , ** self . sns_settings ) topic = sns . create_topic ( Name = topic_name ) return TopicWrapper ( topic ) def get_queue ( self , queue_name : str ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) return QueueWrapper ( sqs_res . get_queue_by_name ( QueueName = queue_name )) def _subscribe_to_topics ( self , queue : QueueWrapper , topics_to_bind : Iterable [ TopicWrapper ], ** kwargs : Any ) -> None : if topics_to_bind : statements = [] for topic in topics_to_bind : statement = { \"Sid\" : \"Sid {} \" . format ( uuid . uuid4 ()), \"Effect\" : \"Allow\" , \"Principal\" : \"*\" , \"Resource\" : queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"Action\" : \"sqs:SendMessage\" , \"Condition\" : { \"ArnEquals\" : { \"aws:SourceArn\" : topic . unwrapped_obj . arn } }, } statements . append ( statement ) subscription = topic . unwrapped_obj . subscribe ( Protocol = \"sqs\" , Endpoint = queue . unwrapped_obj . attributes [ \"QueueArn\" ], # , Attributes={\"RawMessageDelivery\": \"true\"} ) if kwargs . get ( \"filter_events\" ): filter_policy = { \"manifest\" : kwargs [ \"filter_events\" ]} else : filter_policy = {} subscription . set_attributes ( AttributeName = \"FilterPolicy\" , AttributeValue = json . dumps ( filter_policy ), ) policy = { \"Version\" : \"2012-10-17\" , \"Id\" : \"sqspolicy\" , \"Statement\" : statements , } queue . unwrapped_obj . set_attributes ( Attributes = { \"Policy\" : json . dumps ( policy )} ) def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any , ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: try : queue = self . get_queue ( queue_name ) except Exception : queue = self . _create_queue ( queue_name , content_based_deduplication = \"true\" ) self . _subscribe_to_topics ( queue , topics_to_bind , ** kwargs ) dead_letter_queue : Optional [ QueueWrapper ] = None if dead_letter_queue_name : try : dead_letter_queue = self . get_queue ( dead_letter_queue_name ) except Exception : dead_letter_queue = self . _create_queue ( dead_letter_queue_name , content_based_deduplication = \"true\" ) redrive_policy = { \"deadLetterTargetArn\" : dead_letter_queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"maxReceiveCount\" : \"4\" , } queue . unwrapped_obj . set_attributes ( Attributes = { \"RedrivePolicy\" : json . dumps ( redrive_policy )} ) return queue , dead_letter_queue def _create_queue ( self , queue_name : str , ** kwargs : Any ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) fifo = queue_name . endswith ( \".fifo\" ) attributes = {} if fifo : attributes [ \"FifoQueue\" ] = \"true\" attributes [ \"ContentBasedDeduplication\" ] = ( \"true\" if kwargs . get ( \"content_based_deduplication\" ) else \"false\" ) queue = sqs_res . create_queue ( QueueName = queue_name , Attributes = attributes ) return QueueWrapper ( queue ) def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: args = dict ( MaxNumberOfMessages = self . max_number_of_messages , VisibilityTimeout = self . visibility_timeout , WaitTimeSeconds = self . wait_time_seconds , MessageAttributeNames = [ \"All\" ], AttributeNames = [ \"All\" ], ) if \"attempt_id\" in kwargs : args [ \"ReceiveRequestAttemptId\" ] = kwargs [ \"attempt_id\" ] messages = queue . unwrapped_obj . receive_messages ( ** args ) # We need to differentiate here whether the message came from SNS or SQS return [ self . _construct_message ( message ) for message in messages ] def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : message_args : Dict = {} message_args [ \"MessageBody\" ] = json . dumps ({ \"Message\" : message . content }) is_fifo = queue . unwrapped_obj . attributes . get ( \"FifoQueue\" ) == \"true\" message_deduplication_id = ( None if not is_fifo else kwargs . get ( \"message_deduplication_id\" , str ( uuid . uuid4 ())) ) if message . manifest : message_args [ \"MessageAttributes\" ] = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest } } if kwargs . get ( \"message_group_id\" ): message_args [ \"MessageGroupId\" ] = kwargs [ \"message_group_id\" ] if message_deduplication_id : message_args [ \"MessageDeduplicationId\" ] = message_deduplication_id queue . unwrapped_obj . send_message ( ** message_args ) def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : args : Dict = dict ( Message = message . content , MessageAttributes = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest or \"\" , } }, ) if extra_attributes : if \"subject\" in extra_attributes : args [ \"Subject\" ] = extra_attributes [ \"subject\" ] if \"message_attributes\" in extra_attributes : args [ \"MessageAttributes\" ] . update ( extra_attributes [ \"message_attributes\" ]) if \"message_structure\" in extra_attributes : args [ \"MessageStructure\" ] = extra_attributes [ \"message_structure\" ] response = topic . unwrapped_obj . publish ( ** args ) if \"MessageId\" not in response : raise ConnectionError ( \"Could not send the event to the SNS TOPIC\" ) def acknowledge ( self , message : Message ) -> None : message . metadata . delete () def close_connection ( self ) -> None : pass def delete_queue ( self , queue : QueueWrapper ) -> None : queue . unwrapped_obj . delete () def delete_topic ( self , topic : TopicWrapper ) -> None : topic . unwrapped_obj . delete () def _construct_message ( self , message : Any ) -> Message : body = message . body manifest : Optional [ str ] = None try : message_content = json . loads ( body ) if \"Message\" in message_content : content = message_content [ \"Message\" ] # Does the content have more attributes? If so, it is very likely that the message came from a non-raw # SNS redirection if \"MessageAttributes\" in message_content : manifest = ( message_content [ \"MessageAttributes\" ] . get ( \"manifest\" , {}) . get ( \"Value\" ) or \"\" ) else : content = message_content except JSONDecodeError : content = body try : manifest = manifest or message . message_attributes . get ( \"manifest\" , {}) . get ( \"StringValue\" ) except Exception : manifest = None return Message ( message . message_id , content , message , manifest ) acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/sqs/sqs_backend.py def acknowledge ( self , message : Message ) -> None : message . metadata . delete () close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/sqs/sqs_backend.py def close_connection ( self ) -> None : pass declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/sqs/sqs_backend.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any , ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: try : queue = self . get_queue ( queue_name ) except Exception : queue = self . _create_queue ( queue_name , content_based_deduplication = \"true\" ) self . _subscribe_to_topics ( queue , topics_to_bind , ** kwargs ) dead_letter_queue : Optional [ QueueWrapper ] = None if dead_letter_queue_name : try : dead_letter_queue = self . get_queue ( dead_letter_queue_name ) except Exception : dead_letter_queue = self . _create_queue ( dead_letter_queue_name , content_based_deduplication = \"true\" ) redrive_policy = { \"deadLetterTargetArn\" : dead_letter_queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"maxReceiveCount\" : \"4\" , } queue . unwrapped_obj . set_attributes ( Attributes = { \"RedrivePolicy\" : json . dumps ( redrive_policy )} ) return queue , dead_letter_queue declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/sqs/sqs_backend.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : sns = boto3 . resource ( \"sns\" , ** self . sns_settings ) topic = sns . create_topic ( Name = topic_name ) return TopicWrapper ( topic ) delete_queue ( self , queue ) Deletes the queue Source code in melange/backends/sqs/sqs_backend.py def delete_queue ( self , queue : QueueWrapper ) -> None : queue . unwrapped_obj . delete () delete_topic ( self , topic ) Deletes the topic Source code in melange/backends/sqs/sqs_backend.py def delete_topic ( self , topic : TopicWrapper ) -> None : topic . unwrapped_obj . delete () get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/sqs/sqs_backend.py def get_queue ( self , queue_name : str ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) return QueueWrapper ( sqs_res . get_queue_by_name ( QueueName = queue_name )) publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/sqs/sqs_backend.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : args : Dict = dict ( Message = message . content , MessageAttributes = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest or \"\" , } }, ) if extra_attributes : if \"subject\" in extra_attributes : args [ \"Subject\" ] = extra_attributes [ \"subject\" ] if \"message_attributes\" in extra_attributes : args [ \"MessageAttributes\" ] . update ( extra_attributes [ \"message_attributes\" ]) if \"message_structure\" in extra_attributes : args [ \"MessageStructure\" ] = extra_attributes [ \"message_structure\" ] response = topic . unwrapped_obj . publish ( ** args ) if \"MessageId\" not in response : raise ConnectionError ( \"Could not send the event to the SNS TOPIC\" ) retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/sqs/sqs_backend.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: args = dict ( MaxNumberOfMessages = self . max_number_of_messages , VisibilityTimeout = self . visibility_timeout , WaitTimeSeconds = self . wait_time_seconds , MessageAttributeNames = [ \"All\" ], AttributeNames = [ \"All\" ], ) if \"attempt_id\" in kwargs : args [ \"ReceiveRequestAttemptId\" ] = kwargs [ \"attempt_id\" ] messages = queue . unwrapped_obj . receive_messages ( ** args ) # We need to differentiate here whether the message came from SNS or SQS return [ self . _construct_message ( message ) for message in messages ]","title":"Messaging Backends"},{"location":"api-reference/messaging-backends/#messaging-backends","text":"","title":"Messaging Backends"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend","text":"Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"MessagingBackend"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError","title":"acknowledge()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass","title":"close_connection()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError","title":"declare_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError","title":"declare_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_queue","text":"Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError","title":"delete_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_topic","text":"Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"delete_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError","title":"get_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/interfaces.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError","title":"publish_to_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError","title":"retrieve_messages()"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager","text":"Source code in melange/backends/backend_manager.py class BackendManager ( metaclass = Singleton ): def __init__ ( self ) -> None : self . _backend : Optional [ MessagingBackend ] = None def set_default_backend ( self , backend : MessagingBackend , ) -> None : \"\"\" Sets the default backend Args: backend: \"\"\" if not isinstance ( backend , MessagingBackend ): raise Exception ( \"Invalid backend supplied\" ) self . _backend = backend def get_default_backend ( self ) -> MessagingBackend : \"\"\" Returns the current default backend \"\"\" if not self . _backend : raise Exception ( \"No backend is registered. Please call 'set_default_backend' prior to getting it\" ) return self . _backend","title":"BackendManager"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager.get_default_backend","text":"Returns the current default backend Source code in melange/backends/backend_manager.py def get_default_backend ( self ) -> MessagingBackend : \"\"\" Returns the current default backend \"\"\" if not self . _backend : raise Exception ( \"No backend is registered. Please call 'set_default_backend' prior to getting it\" ) return self . _backend","title":"get_default_backend()"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager.set_default_backend","text":"Sets the default backend Parameters: Name Type Description Default backend MessagingBackend required Source code in melange/backends/backend_manager.py def set_default_backend ( self , backend : MessagingBackend , ) -> None : \"\"\" Sets the default backend Args: backend: \"\"\" if not isinstance ( backend , MessagingBackend ): raise Exception ( \"Invalid backend supplied\" ) self . _backend = backend","title":"set_default_backend()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.AWSBackend","text":"Backend to use with AWS Source code in melange/backends/sqs/sqs_backend.py class AWSBackend ( BaseSQSBackend ): \"\"\" Backend to use with AWS \"\"\" def __init__ ( self , ** kwargs : Any ) -> None : super () . __init__ ( ** kwargs )","title":"AWSBackend"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend","text":"Base class for SQS Backends Source code in melange/backends/sqs/sqs_backend.py class BaseSQSBackend ( MessagingBackend ): \"\"\" Base class for SQS Backends \"\"\" def __init__ ( self , ** kwargs : Any ) -> None : super () . __init__ () self . max_number_of_messages = kwargs . get ( \"max_number_of_messages\" , 10 ) self . visibility_timeout = kwargs . get ( \"visibility_timeout\" , 100 ) self . wait_time_seconds = kwargs . get ( \"wait_time_seconds\" , 10 ) self . extra_settings = kwargs . get ( \"extra_settings\" , {}) self . sns_settings = kwargs . get ( \"sns_settings\" , {}) def declare_topic ( self , topic_name : str ) -> TopicWrapper : sns = boto3 . resource ( \"sns\" , ** self . sns_settings ) topic = sns . create_topic ( Name = topic_name ) return TopicWrapper ( topic ) def get_queue ( self , queue_name : str ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) return QueueWrapper ( sqs_res . get_queue_by_name ( QueueName = queue_name )) def _subscribe_to_topics ( self , queue : QueueWrapper , topics_to_bind : Iterable [ TopicWrapper ], ** kwargs : Any ) -> None : if topics_to_bind : statements = [] for topic in topics_to_bind : statement = { \"Sid\" : \"Sid {} \" . format ( uuid . uuid4 ()), \"Effect\" : \"Allow\" , \"Principal\" : \"*\" , \"Resource\" : queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"Action\" : \"sqs:SendMessage\" , \"Condition\" : { \"ArnEquals\" : { \"aws:SourceArn\" : topic . unwrapped_obj . arn } }, } statements . append ( statement ) subscription = topic . unwrapped_obj . subscribe ( Protocol = \"sqs\" , Endpoint = queue . unwrapped_obj . attributes [ \"QueueArn\" ], # , Attributes={\"RawMessageDelivery\": \"true\"} ) if kwargs . get ( \"filter_events\" ): filter_policy = { \"manifest\" : kwargs [ \"filter_events\" ]} else : filter_policy = {} subscription . set_attributes ( AttributeName = \"FilterPolicy\" , AttributeValue = json . dumps ( filter_policy ), ) policy = { \"Version\" : \"2012-10-17\" , \"Id\" : \"sqspolicy\" , \"Statement\" : statements , } queue . unwrapped_obj . set_attributes ( Attributes = { \"Policy\" : json . dumps ( policy )} ) def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any , ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: try : queue = self . get_queue ( queue_name ) except Exception : queue = self . _create_queue ( queue_name , content_based_deduplication = \"true\" ) self . _subscribe_to_topics ( queue , topics_to_bind , ** kwargs ) dead_letter_queue : Optional [ QueueWrapper ] = None if dead_letter_queue_name : try : dead_letter_queue = self . get_queue ( dead_letter_queue_name ) except Exception : dead_letter_queue = self . _create_queue ( dead_letter_queue_name , content_based_deduplication = \"true\" ) redrive_policy = { \"deadLetterTargetArn\" : dead_letter_queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"maxReceiveCount\" : \"4\" , } queue . unwrapped_obj . set_attributes ( Attributes = { \"RedrivePolicy\" : json . dumps ( redrive_policy )} ) return queue , dead_letter_queue def _create_queue ( self , queue_name : str , ** kwargs : Any ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) fifo = queue_name . endswith ( \".fifo\" ) attributes = {} if fifo : attributes [ \"FifoQueue\" ] = \"true\" attributes [ \"ContentBasedDeduplication\" ] = ( \"true\" if kwargs . get ( \"content_based_deduplication\" ) else \"false\" ) queue = sqs_res . create_queue ( QueueName = queue_name , Attributes = attributes ) return QueueWrapper ( queue ) def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: args = dict ( MaxNumberOfMessages = self . max_number_of_messages , VisibilityTimeout = self . visibility_timeout , WaitTimeSeconds = self . wait_time_seconds , MessageAttributeNames = [ \"All\" ], AttributeNames = [ \"All\" ], ) if \"attempt_id\" in kwargs : args [ \"ReceiveRequestAttemptId\" ] = kwargs [ \"attempt_id\" ] messages = queue . unwrapped_obj . receive_messages ( ** args ) # We need to differentiate here whether the message came from SNS or SQS return [ self . _construct_message ( message ) for message in messages ] def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : message_args : Dict = {} message_args [ \"MessageBody\" ] = json . dumps ({ \"Message\" : message . content }) is_fifo = queue . unwrapped_obj . attributes . get ( \"FifoQueue\" ) == \"true\" message_deduplication_id = ( None if not is_fifo else kwargs . get ( \"message_deduplication_id\" , str ( uuid . uuid4 ())) ) if message . manifest : message_args [ \"MessageAttributes\" ] = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest } } if kwargs . get ( \"message_group_id\" ): message_args [ \"MessageGroupId\" ] = kwargs [ \"message_group_id\" ] if message_deduplication_id : message_args [ \"MessageDeduplicationId\" ] = message_deduplication_id queue . unwrapped_obj . send_message ( ** message_args ) def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : args : Dict = dict ( Message = message . content , MessageAttributes = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest or \"\" , } }, ) if extra_attributes : if \"subject\" in extra_attributes : args [ \"Subject\" ] = extra_attributes [ \"subject\" ] if \"message_attributes\" in extra_attributes : args [ \"MessageAttributes\" ] . update ( extra_attributes [ \"message_attributes\" ]) if \"message_structure\" in extra_attributes : args [ \"MessageStructure\" ] = extra_attributes [ \"message_structure\" ] response = topic . unwrapped_obj . publish ( ** args ) if \"MessageId\" not in response : raise ConnectionError ( \"Could not send the event to the SNS TOPIC\" ) def acknowledge ( self , message : Message ) -> None : message . metadata . delete () def close_connection ( self ) -> None : pass def delete_queue ( self , queue : QueueWrapper ) -> None : queue . unwrapped_obj . delete () def delete_topic ( self , topic : TopicWrapper ) -> None : topic . unwrapped_obj . delete () def _construct_message ( self , message : Any ) -> Message : body = message . body manifest : Optional [ str ] = None try : message_content = json . loads ( body ) if \"Message\" in message_content : content = message_content [ \"Message\" ] # Does the content have more attributes? If so, it is very likely that the message came from a non-raw # SNS redirection if \"MessageAttributes\" in message_content : manifest = ( message_content [ \"MessageAttributes\" ] . get ( \"manifest\" , {}) . get ( \"Value\" ) or \"\" ) else : content = message_content except JSONDecodeError : content = body try : manifest = manifest or message . message_attributes . get ( \"manifest\" , {}) . get ( \"StringValue\" ) except Exception : manifest = None return Message ( message . message_id , content , message , manifest )","title":"BaseSQSBackend"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/sqs/sqs_backend.py def acknowledge ( self , message : Message ) -> None : message . metadata . delete ()","title":"acknowledge()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/sqs/sqs_backend.py def close_connection ( self ) -> None : pass","title":"close_connection()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/sqs/sqs_backend.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any , ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: try : queue = self . get_queue ( queue_name ) except Exception : queue = self . _create_queue ( queue_name , content_based_deduplication = \"true\" ) self . _subscribe_to_topics ( queue , topics_to_bind , ** kwargs ) dead_letter_queue : Optional [ QueueWrapper ] = None if dead_letter_queue_name : try : dead_letter_queue = self . get_queue ( dead_letter_queue_name ) except Exception : dead_letter_queue = self . _create_queue ( dead_letter_queue_name , content_based_deduplication = \"true\" ) redrive_policy = { \"deadLetterTargetArn\" : dead_letter_queue . unwrapped_obj . attributes [ \"QueueArn\" ], \"maxReceiveCount\" : \"4\" , } queue . unwrapped_obj . set_attributes ( Attributes = { \"RedrivePolicy\" : json . dumps ( redrive_policy )} ) return queue , dead_letter_queue","title":"declare_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/sqs/sqs_backend.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : sns = boto3 . resource ( \"sns\" , ** self . sns_settings ) topic = sns . create_topic ( Name = topic_name ) return TopicWrapper ( topic )","title":"declare_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.delete_queue","text":"Deletes the queue Source code in melange/backends/sqs/sqs_backend.py def delete_queue ( self , queue : QueueWrapper ) -> None : queue . unwrapped_obj . delete ()","title":"delete_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.delete_topic","text":"Deletes the topic Source code in melange/backends/sqs/sqs_backend.py def delete_topic ( self , topic : TopicWrapper ) -> None : topic . unwrapped_obj . delete ()","title":"delete_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/sqs/sqs_backend.py def get_queue ( self , queue_name : str ) -> QueueWrapper : sqs_res = boto3 . resource ( \"sqs\" , ** self . extra_settings ) return QueueWrapper ( sqs_res . get_queue_by_name ( QueueName = queue_name ))","title":"get_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/sqs/sqs_backend.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : args : Dict = dict ( Message = message . content , MessageAttributes = { \"manifest\" : { \"DataType\" : \"String\" , \"StringValue\" : message . manifest or \"\" , } }, ) if extra_attributes : if \"subject\" in extra_attributes : args [ \"Subject\" ] = extra_attributes [ \"subject\" ] if \"message_attributes\" in extra_attributes : args [ \"MessageAttributes\" ] . update ( extra_attributes [ \"message_attributes\" ]) if \"message_structure\" in extra_attributes : args [ \"MessageStructure\" ] = extra_attributes [ \"message_structure\" ] response = topic . unwrapped_obj . publish ( ** args ) if \"MessageId\" not in response : raise ConnectionError ( \"Could not send the event to the SNS TOPIC\" )","title":"publish_to_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/sqs/sqs_backend.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: args = dict ( MaxNumberOfMessages = self . max_number_of_messages , VisibilityTimeout = self . visibility_timeout , WaitTimeSeconds = self . wait_time_seconds , MessageAttributeNames = [ \"All\" ], AttributeNames = [ \"All\" ], ) if \"attempt_id\" in kwargs : args [ \"ReceiveRequestAttemptId\" ] = kwargs [ \"attempt_id\" ] messages = queue . unwrapped_obj . receive_messages ( ** args ) # We need to differentiate here whether the message came from SNS or SQS return [ self . _construct_message ( message ) for message in messages ]","title":"retrieve_messages()"},{"location":"api-reference/publishers/","text":"Publishers QueuePublisher Source code in melange/publishers.py class QueuePublisher : def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_default_backend () self . message_serializer = message_serializer def publish ( self , queue_name : str , data : Any , ** kwargs : Any ) -> None : \"\"\" Publishes data to a queue Args: queue_name: The queue to send the message to. data: The data to send to this queue. It will be serialized before sending to the queue using the serializers. **kwargs: Any extra attributes. They will be passed to the backend upon publish. \"\"\" content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) queue = self . _backend . get_queue ( queue_name ) self . _backend . publish_to_queue ( Message . create ( content , manifest ), queue , ** kwargs ) publish ( self , queue_name , data , ** kwargs ) Publishes data to a queue Parameters: Name Type Description Default queue_name str The queue to send the message to. required data Any The data to send to this queue. It will be serialized before sending to the queue using the serializers. required **kwargs Any Any extra attributes. They will be passed to the backend upon publish. {} Source code in melange/publishers.py def publish ( self , queue_name : str , data : Any , ** kwargs : Any ) -> None : \"\"\" Publishes data to a queue Args: queue_name: The queue to send the message to. data: The data to send to this queue. It will be serialized before sending to the queue using the serializers. **kwargs: Any extra attributes. They will be passed to the backend upon publish. \"\"\" content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) queue = self . _backend . get_queue ( queue_name ) self . _backend . publish_to_queue ( Message . create ( content , manifest ), queue , ** kwargs ) TopicPublisher Source code in melange/publishers.py class TopicPublisher : def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_default_backend () self . message_serializer = message_serializer def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> None : \"\"\" Publishes data to a topic Args: topic_name: The topic to send the message to. data: The data to send to this topic. It will be serialized before sending to the topic using the serializers. **extra_attributes: Any extra attributes. They will be passed to the backend upon publishing. \"\"\" topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish_to_topic ( Message . create ( content , manifest ), topic , extra_attributes = extra_attributes , ) publish ( self , topic_name , data , ** extra_attributes ) Publishes data to a topic Parameters: Name Type Description Default topic_name str The topic to send the message to. required data Any The data to send to this topic. It will be serialized before sending to the topic using the serializers. required **extra_attributes Any Any extra attributes. They will be passed to the backend upon publishing. {} Source code in melange/publishers.py def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> None : \"\"\" Publishes data to a topic Args: topic_name: The topic to send the message to. data: The data to send to this topic. It will be serialized before sending to the topic using the serializers. **extra_attributes: Any extra attributes. They will be passed to the backend upon publishing. \"\"\" topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish_to_topic ( Message . create ( content , manifest ), topic , extra_attributes = extra_attributes , )","title":"Publishers"},{"location":"api-reference/publishers/#publishers","text":"","title":"Publishers"},{"location":"api-reference/publishers/#melange.publishers.QueuePublisher","text":"Source code in melange/publishers.py class QueuePublisher : def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_default_backend () self . message_serializer = message_serializer def publish ( self , queue_name : str , data : Any , ** kwargs : Any ) -> None : \"\"\" Publishes data to a queue Args: queue_name: The queue to send the message to. data: The data to send to this queue. It will be serialized before sending to the queue using the serializers. **kwargs: Any extra attributes. They will be passed to the backend upon publish. \"\"\" content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) queue = self . _backend . get_queue ( queue_name ) self . _backend . publish_to_queue ( Message . create ( content , manifest ), queue , ** kwargs )","title":"QueuePublisher"},{"location":"api-reference/publishers/#melange.publishers.QueuePublisher.publish","text":"Publishes data to a queue Parameters: Name Type Description Default queue_name str The queue to send the message to. required data Any The data to send to this queue. It will be serialized before sending to the queue using the serializers. required **kwargs Any Any extra attributes. They will be passed to the backend upon publish. {} Source code in melange/publishers.py def publish ( self , queue_name : str , data : Any , ** kwargs : Any ) -> None : \"\"\" Publishes data to a queue Args: queue_name: The queue to send the message to. data: The data to send to this queue. It will be serialized before sending to the queue using the serializers. **kwargs: Any extra attributes. They will be passed to the backend upon publish. \"\"\" content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) queue = self . _backend . get_queue ( queue_name ) self . _backend . publish_to_queue ( Message . create ( content , manifest ), queue , ** kwargs )","title":"publish()"},{"location":"api-reference/publishers/#melange.publishers.TopicPublisher","text":"Source code in melange/publishers.py class TopicPublisher : def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_default_backend () self . message_serializer = message_serializer def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> None : \"\"\" Publishes data to a topic Args: topic_name: The topic to send the message to. data: The data to send to this topic. It will be serialized before sending to the topic using the serializers. **extra_attributes: Any extra attributes. They will be passed to the backend upon publishing. \"\"\" topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish_to_topic ( Message . create ( content , manifest ), topic , extra_attributes = extra_attributes , )","title":"TopicPublisher"},{"location":"api-reference/publishers/#melange.publishers.TopicPublisher.publish","text":"Publishes data to a topic Parameters: Name Type Description Default topic_name str The topic to send the message to. required data Any The data to send to this topic. It will be serialized before sending to the topic using the serializers. required **extra_attributes Any Any extra attributes. They will be passed to the backend upon publishing. {} Source code in melange/publishers.py def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> None : \"\"\" Publishes data to a topic Args: topic_name: The topic to send the message to. data: The data to send to this topic. It will be serialized before sending to the topic using the serializers. **extra_attributes: Any extra attributes. They will be passed to the backend upon publishing. \"\"\" topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish_to_topic ( Message . create ( content , manifest ), topic , extra_attributes = extra_attributes , )","title":"publish()"},{"location":"api-reference/serializers/","text":"Serializers MessageSerializer ( Generic ) Base interface to inherit for all the serializers Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers \"\"\" def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object Source code in melange/serializers/interfaces.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object Source code in melange/serializers/interfaces.py def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass JsonSerializer ( MessageSerializer ) Serializes and deserializes python dictionaries in json format Source code in melange/serializers/json.py class JsonSerializer ( MessageSerializer [ Dict ]): \"\"\" Serializes and deserializes python dictionaries in json format \"\"\" def manifest ( self , data : Dict ) -> str : return \"json\" def deserialize ( self , serialized_data : str , manifest : Optional [ str ] = None ) -> Dict : data = json . loads ( serialized_data ) return data def serialize ( self , data : Dict ) -> str : return json . dumps ( data ) deserialize ( self , serialized_data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description Dict The data object Source code in melange/serializers/json.py def deserialize ( self , serialized_data : str , manifest : Optional [ str ] = None ) -> Dict : data = json . loads ( serialized_data ) return data manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data Dict required Returns: Type Description str The manifest of the object Source code in melange/serializers/json.py def manifest ( self , data : Dict ) -> str : return \"json\" serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data Dict the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/json.py def serialize ( self , data : Dict ) -> str : return json . dumps ( data ) PickleSerializer ( MessageSerializer ) Serializes DomainEvents with pickle. Source code in melange/serializers/pickle.py class PickleSerializer ( MessageSerializer [ DomainEvent ]): \"\"\" Serializes DomainEvents with pickle. \"\"\" def manifest ( self , data : DomainEvent ) -> str : return data . __class__ . __qualname__ def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> DomainEvent : return pickle . loads ( codecs . decode ( data . encode (), \"base64\" )) def serialize ( self , data : DomainEvent ) -> str : return codecs . encode ( pickle . dumps ( data ), \"base64\" ) . decode () deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description DomainEvent The data object Source code in melange/serializers/pickle.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> DomainEvent : return pickle . loads ( codecs . decode ( data . encode (), \"base64\" )) manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data DomainEvent required Returns: Type Description str The manifest of the object Source code in melange/serializers/pickle.py def manifest ( self , data : DomainEvent ) -> str : return data . __class__ . __qualname__ serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data DomainEvent the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/pickle.py def serialize ( self , data : DomainEvent ) -> str : return codecs . encode ( pickle . dumps ( data ), \"base64\" ) . decode ()","title":"Serializers"},{"location":"api-reference/serializers/#serializers","text":"","title":"Serializers"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer","text":"Base interface to inherit for all the serializers Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers \"\"\" def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass","title":"MessageSerializer"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object Source code in melange/serializers/interfaces.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object Source code in melange/serializers/interfaces.py def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass","title":"serialize()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer","text":"Serializes and deserializes python dictionaries in json format Source code in melange/serializers/json.py class JsonSerializer ( MessageSerializer [ Dict ]): \"\"\" Serializes and deserializes python dictionaries in json format \"\"\" def manifest ( self , data : Dict ) -> str : return \"json\" def deserialize ( self , serialized_data : str , manifest : Optional [ str ] = None ) -> Dict : data = json . loads ( serialized_data ) return data def serialize ( self , data : Dict ) -> str : return json . dumps ( data )","title":"JsonSerializer"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description Dict The data object Source code in melange/serializers/json.py def deserialize ( self , serialized_data : str , manifest : Optional [ str ] = None ) -> Dict : data = json . loads ( serialized_data ) return data","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data Dict required Returns: Type Description str The manifest of the object Source code in melange/serializers/json.py def manifest ( self , data : Dict ) -> str : return \"json\"","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data Dict the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/json.py def serialize ( self , data : Dict ) -> str : return json . dumps ( data )","title":"serialize()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer","text":"Serializes DomainEvents with pickle. Source code in melange/serializers/pickle.py class PickleSerializer ( MessageSerializer [ DomainEvent ]): \"\"\" Serializes DomainEvents with pickle. \"\"\" def manifest ( self , data : DomainEvent ) -> str : return data . __class__ . __qualname__ def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> DomainEvent : return pickle . loads ( codecs . decode ( data . encode (), \"base64\" )) def serialize ( self , data : DomainEvent ) -> str : return codecs . encode ( pickle . dumps ( data ), \"base64\" ) . decode ()","title":"PickleSerializer"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description DomainEvent The data object Source code in melange/serializers/pickle.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> DomainEvent : return pickle . loads ( codecs . decode ( data . encode (), \"base64\" ))","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data DomainEvent required Returns: Type Description str The manifest of the object Source code in melange/serializers/pickle.py def manifest ( self , data : DomainEvent ) -> str : return data . __class__ . __qualname__","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data DomainEvent the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/pickle.py def serialize ( self , data : DomainEvent ) -> str : return codecs . encode ( pickle . dumps ( data ), \"base64\" ) . decode ()","title":"serialize()"},{"location":"components/consumers/","text":"Message Dispatchers and Consumers Message Dispatcher and Consumers are the counterpart of the publishers. Consumers attach themselves to a Message Dispatcher, and the message dispatchers start the consuming loop and receive the messages from a queue, forwarding them to a consumer that accepts that message. Consumers Consumers are very simple, since they only receive a Message as a parameter and then they do some kind of processing to send it down to the lower layers of your application (something like a REST view/controller). To mplement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method, and, optionally, the accepts method. Example (from examples/payment_service/consumer_draft.py ): from typing import Any , Optional from melange.consumers import Consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( Consumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service def process ( self , message : Any , ** kwargs : Any ) -> None : if isinstance ( message , OrderResponse ): self . payment_service . process ( message ) elif isinstance ( message , DoPayment ): self . payment_service . do_payment ( message ) def accepts ( self , manifest : Optional [ str ]) -> bool : return manifest in [ \"OrderResponse\" , \"DoPayment\" ] There is a variation of the Consumer , the SingleDispatchConsumer consumer. It relies on the singledispatch library to implement method overloading on the process function, in order to achieve a richer accepts and process methods. This has proven to make the development of complex consumers faster and cleaner. The same PaymentConsumer as above, but implemented by subclassing SingleDispatchConsumer (from examples/payment_service/consumer.py ): from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( SingleDispatchConsumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service @consumer def consume_order_response ( self , event : OrderResponse ) -> None : self . payment_service . process ( event ) @consumer def consume_do_payment ( self , command : DoPayment ) -> None : self . payment_service . do_payment ( command ) For a consumer to be able to receive messages it requires to be attached to a MessageDispatcher Message Dispatcher As summarized on top of this article, the MessageDispatcher component/class is the responsible to: Start the polling loop to get new messages through the MessagingBackend . Deserialize the message with the appropriate MessageSerializer . Pass the message to the consumers that accept it for further processing. Acknowledge the message. There is a variation of the MessageDispatcher called SimpleMessageDispatcher which is essentially the same as the former, but when you have only one consumer. This is the specification of the MessageDispatcher class: The MessageDispatcher is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers. Source code in melange/message_dispatcher.py class MessageDispatcher : \"\"\" The `MessageDispatcher` is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers. \"\"\" def __init__ ( self , message_serializer : MessageSerializer , cache : Optional [ DeduplicationCache ] = None , backend : Optional [ MessagingBackend ] = None , always_ack : bool = False , ) -> None : self . _exchange_listeners : List [ Consumer ] = [] self . message_serializer = message_serializer self . _backend = backend or BackendManager () . get_default_backend () self . cache : DeduplicationCache = cache or NullCache () self . always_ack = always_ack def attach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Attaches a consumer to the dispatcher, so that it can receive messages Args: consumer: the consumer to attach \"\"\" if consumer not in self . _exchange_listeners : self . _exchange_listeners . append ( consumer ) def unattach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Args: consumer: the consumer to unattach \"\"\" if consumer in self . _exchange_listeners : self . _exchange_listeners . remove ( consumer ) def consume_loop ( self , queue_name : str , on_exception : Optional [ Callable [[ Exception ], None ]] = None , after_consume : Optional [ Callable [[], None ]] = None , ) -> None : \"\"\" Starts the consumption loop on the queue `queue_name` Args: queue_name: The queue to poll for new messages on_exception: If there is any exception, the exception will be passed to this callback after_consume: After consuming a batch of events, invoke this callback \"\"\" while True : try : self . consume_event ( queue_name ) except Exception as e : logger . exception ( e ) if on_exception : on_exception ( e ) finally : if after_consume : after_consume () def consume_event ( self , queue_name : str ) -> None : \"\"\" Consumes one event on the queue `queue_name` Args: queue_name: The queue to consume from \"\"\" event_queue = self . _backend . get_queue ( queue_name ) messages = self . _backend . retrieve_messages ( event_queue ) for message in messages : try : self . _dispatch_message ( message ) except Exception as e : logger . exception ( e ) def _get_consumers ( self , message_data : Any ) -> List [ Consumer ]: return [ listener for listener in self . _exchange_listeners if listener . accepts ( message_data ) ] def _dispatch_message ( self , message : Message ) -> None : manifest = message . get_message_manifest () message_data = self . message_serializer . deserialize ( message . content , manifest = manifest ) consumers = self . _get_consumers ( message_data ) successful = 0 for consumer in consumers : try : # Store into the cache message_key = ( f \" { get_fully_qualified_name ( consumer ) } . { message . message_id } \" ) if message_key in self . cache : logger . info ( \"detected a duplicated message, ignoring\" ) else : consumer . process ( message_data , message_id = message . message_id ) successful += 1 self . cache . store ( message_key , message_key ) except Exception as e : logger . exception ( e ) if self . always_ack or successful == len ( consumers ): self . _backend . acknowledge ( message ) attach_consumer ( self , consumer ) Attaches a consumer to the dispatcher, so that it can receive messages Parameters: Name Type Description Default consumer Consumer the consumer to attach required Source code in melange/message_dispatcher.py def attach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Attaches a consumer to the dispatcher, so that it can receive messages Args: consumer: the consumer to attach \"\"\" if consumer not in self . _exchange_listeners : self . _exchange_listeners . append ( consumer ) consume_event ( self , queue_name ) Consumes one event on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to consume from required Source code in melange/message_dispatcher.py def consume_event ( self , queue_name : str ) -> None : \"\"\" Consumes one event on the queue `queue_name` Args: queue_name: The queue to consume from \"\"\" event_queue = self . _backend . get_queue ( queue_name ) messages = self . _backend . retrieve_messages ( event_queue ) for message in messages : try : self . _dispatch_message ( message ) except Exception as e : logger . exception ( e ) consume_loop ( self , queue_name , on_exception = None , after_consume = None ) Starts the consumption loop on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to poll for new messages required on_exception Optional[Callable[[Exception], NoneType]] If there is any exception, the exception will be passed to this callback None after_consume Optional[Callable[[], NoneType]] After consuming a batch of events, invoke this callback None Source code in melange/message_dispatcher.py def consume_loop ( self , queue_name : str , on_exception : Optional [ Callable [[ Exception ], None ]] = None , after_consume : Optional [ Callable [[], None ]] = None , ) -> None : \"\"\" Starts the consumption loop on the queue `queue_name` Args: queue_name: The queue to poll for new messages on_exception: If there is any exception, the exception will be passed to this callback after_consume: After consuming a batch of events, invoke this callback \"\"\" while True : try : self . consume_event ( queue_name ) except Exception as e : logger . exception ( e ) if on_exception : on_exception ( e ) finally : if after_consume : after_consume () unattach_consumer ( self , consumer ) Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Parameters: Name Type Description Default consumer Consumer the consumer to unattach required Source code in melange/message_dispatcher.py def unattach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Args: consumer: the consumer to unattach \"\"\" if consumer in self . _exchange_listeners : self . _exchange_listeners . remove ( consumer ) NOTE: Unless the always_ack is set to True , a message will only be acknowleged if it's been correcly processed by all consumers that accept the message. Unless message deduplication is in place, if a consumers fails the same message is going to be reprocessed again by all the consumers, which can lead to issues. Either use only one consumer per MessageDispatcher , make your consumers idempotent, or set a DeduplicationCache when instantiating the MessageDispatcher .","title":"Message Dispatcher and Consumers"},{"location":"components/consumers/#message-dispatchers-and-consumers","text":"Message Dispatcher and Consumers are the counterpart of the publishers. Consumers attach themselves to a Message Dispatcher, and the message dispatchers start the consuming loop and receive the messages from a queue, forwarding them to a consumer that accepts that message.","title":"Message Dispatchers and Consumers"},{"location":"components/consumers/#consumers","text":"Consumers are very simple, since they only receive a Message as a parameter and then they do some kind of processing to send it down to the lower layers of your application (something like a REST view/controller). To mplement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method, and, optionally, the accepts method. Example (from examples/payment_service/consumer_draft.py ): from typing import Any , Optional from melange.consumers import Consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( Consumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service def process ( self , message : Any , ** kwargs : Any ) -> None : if isinstance ( message , OrderResponse ): self . payment_service . process ( message ) elif isinstance ( message , DoPayment ): self . payment_service . do_payment ( message ) def accepts ( self , manifest : Optional [ str ]) -> bool : return manifest in [ \"OrderResponse\" , \"DoPayment\" ] There is a variation of the Consumer , the SingleDispatchConsumer consumer. It relies on the singledispatch library to implement method overloading on the process function, in order to achieve a richer accepts and process methods. This has proven to make the development of complex consumers faster and cleaner. The same PaymentConsumer as above, but implemented by subclassing SingleDispatchConsumer (from examples/payment_service/consumer.py ): from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( SingleDispatchConsumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service @consumer def consume_order_response ( self , event : OrderResponse ) -> None : self . payment_service . process ( event ) @consumer def consume_do_payment ( self , command : DoPayment ) -> None : self . payment_service . do_payment ( command ) For a consumer to be able to receive messages it requires to be attached to a MessageDispatcher","title":"Consumers"},{"location":"components/consumers/#message-dispatcher","text":"As summarized on top of this article, the MessageDispatcher component/class is the responsible to: Start the polling loop to get new messages through the MessagingBackend . Deserialize the message with the appropriate MessageSerializer . Pass the message to the consumers that accept it for further processing. Acknowledge the message. There is a variation of the MessageDispatcher called SimpleMessageDispatcher which is essentially the same as the former, but when you have only one consumer. This is the specification of the MessageDispatcher class: The MessageDispatcher is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers. Source code in melange/message_dispatcher.py class MessageDispatcher : \"\"\" The `MessageDispatcher` is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers. \"\"\" def __init__ ( self , message_serializer : MessageSerializer , cache : Optional [ DeduplicationCache ] = None , backend : Optional [ MessagingBackend ] = None , always_ack : bool = False , ) -> None : self . _exchange_listeners : List [ Consumer ] = [] self . message_serializer = message_serializer self . _backend = backend or BackendManager () . get_default_backend () self . cache : DeduplicationCache = cache or NullCache () self . always_ack = always_ack def attach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Attaches a consumer to the dispatcher, so that it can receive messages Args: consumer: the consumer to attach \"\"\" if consumer not in self . _exchange_listeners : self . _exchange_listeners . append ( consumer ) def unattach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Args: consumer: the consumer to unattach \"\"\" if consumer in self . _exchange_listeners : self . _exchange_listeners . remove ( consumer ) def consume_loop ( self , queue_name : str , on_exception : Optional [ Callable [[ Exception ], None ]] = None , after_consume : Optional [ Callable [[], None ]] = None , ) -> None : \"\"\" Starts the consumption loop on the queue `queue_name` Args: queue_name: The queue to poll for new messages on_exception: If there is any exception, the exception will be passed to this callback after_consume: After consuming a batch of events, invoke this callback \"\"\" while True : try : self . consume_event ( queue_name ) except Exception as e : logger . exception ( e ) if on_exception : on_exception ( e ) finally : if after_consume : after_consume () def consume_event ( self , queue_name : str ) -> None : \"\"\" Consumes one event on the queue `queue_name` Args: queue_name: The queue to consume from \"\"\" event_queue = self . _backend . get_queue ( queue_name ) messages = self . _backend . retrieve_messages ( event_queue ) for message in messages : try : self . _dispatch_message ( message ) except Exception as e : logger . exception ( e ) def _get_consumers ( self , message_data : Any ) -> List [ Consumer ]: return [ listener for listener in self . _exchange_listeners if listener . accepts ( message_data ) ] def _dispatch_message ( self , message : Message ) -> None : manifest = message . get_message_manifest () message_data = self . message_serializer . deserialize ( message . content , manifest = manifest ) consumers = self . _get_consumers ( message_data ) successful = 0 for consumer in consumers : try : # Store into the cache message_key = ( f \" { get_fully_qualified_name ( consumer ) } . { message . message_id } \" ) if message_key in self . cache : logger . info ( \"detected a duplicated message, ignoring\" ) else : consumer . process ( message_data , message_id = message . message_id ) successful += 1 self . cache . store ( message_key , message_key ) except Exception as e : logger . exception ( e ) if self . always_ack or successful == len ( consumers ): self . _backend . acknowledge ( message )","title":"Message Dispatcher"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.attach_consumer","text":"Attaches a consumer to the dispatcher, so that it can receive messages Parameters: Name Type Description Default consumer Consumer the consumer to attach required Source code in melange/message_dispatcher.py def attach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Attaches a consumer to the dispatcher, so that it can receive messages Args: consumer: the consumer to attach \"\"\" if consumer not in self . _exchange_listeners : self . _exchange_listeners . append ( consumer )","title":"attach_consumer()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.consume_event","text":"Consumes one event on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to consume from required Source code in melange/message_dispatcher.py def consume_event ( self , queue_name : str ) -> None : \"\"\" Consumes one event on the queue `queue_name` Args: queue_name: The queue to consume from \"\"\" event_queue = self . _backend . get_queue ( queue_name ) messages = self . _backend . retrieve_messages ( event_queue ) for message in messages : try : self . _dispatch_message ( message ) except Exception as e : logger . exception ( e )","title":"consume_event()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.consume_loop","text":"Starts the consumption loop on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to poll for new messages required on_exception Optional[Callable[[Exception], NoneType]] If there is any exception, the exception will be passed to this callback None after_consume Optional[Callable[[], NoneType]] After consuming a batch of events, invoke this callback None Source code in melange/message_dispatcher.py def consume_loop ( self , queue_name : str , on_exception : Optional [ Callable [[ Exception ], None ]] = None , after_consume : Optional [ Callable [[], None ]] = None , ) -> None : \"\"\" Starts the consumption loop on the queue `queue_name` Args: queue_name: The queue to poll for new messages on_exception: If there is any exception, the exception will be passed to this callback after_consume: After consuming a batch of events, invoke this callback \"\"\" while True : try : self . consume_event ( queue_name ) except Exception as e : logger . exception ( e ) if on_exception : on_exception ( e ) finally : if after_consume : after_consume ()","title":"consume_loop()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.unattach_consumer","text":"Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Parameters: Name Type Description Default consumer Consumer the consumer to unattach required Source code in melange/message_dispatcher.py def unattach_consumer ( self , consumer : Consumer ) -> None : \"\"\" Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Args: consumer: the consumer to unattach \"\"\" if consumer in self . _exchange_listeners : self . _exchange_listeners . remove ( consumer ) NOTE: Unless the always_ack is set to True , a message will only be acknowleged if it's been correcly processed by all consumers that accept the message. Unless message deduplication is in place, if a consumers fails the same message is going to be reprocessed again by all the consumers, which can lead to issues. Either use only one consumer per MessageDispatcher , make your consumers idempotent, or set a DeduplicationCache when instantiating the MessageDispatcher .","title":"unattach_consumer()"},{"location":"components/messaging-backends/","text":"Messaging backends A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The AWSBackend and the LocalSQSBackend . The RabbitMQBackend is present in the source code, but not actively maintained. Looking for contributors! Writing your own Messaging Backend Subclass the MessagingBackend interface and implement all the methods of that class. Here is the documentation of the interface class and all its methods. You need to take in mind, when implementing the methods that return a QueueWrapper or a TopicWrapper , to wrap inside them the real object that represents your queue or topic (in your chosen messaging technology) and unwrap it inside the messaging backend when requiring to perform specific operations. Look at the AWSBackend as a template/example of this wrapping/unwrapping. MessagingBackend Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError delete_queue ( self , queue ) Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError delete_topic ( self , topic ) Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/interfaces.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError","title":"Messaging Backends"},{"location":"components/messaging-backends/#messaging-backends","text":"A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The AWSBackend and the LocalSQSBackend . The RabbitMQBackend is present in the source code, but not actively maintained. Looking for contributors!","title":"Messaging backends"},{"location":"components/messaging-backends/#writing-your-own-messaging-backend","text":"Subclass the MessagingBackend interface and implement all the methods of that class. Here is the documentation of the interface class and all its methods. You need to take in mind, when implementing the methods that return a QueueWrapper or a TopicWrapper , to wrap inside them the real object that represents your queue or topic (in your chosen messaging technology) and unwrap it inside the messaging backend when requiring to perform specific operations. Look at the AWSBackend as a template/example of this wrapping/unwrapping.","title":"Writing your own Messaging Backend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend","text":"Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError def publish_to_queue ( self , message : Message , queue : QueueWrapper , ** kwargs : Any ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"MessagingBackend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError","title":"acknowledge()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass","title":"close_connection()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : TopicWrapper , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ QueueWrapper , Optional [ QueueWrapper ]]: \"\"\" Gets or creates a queue. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError","title":"declare_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> TopicWrapper : \"\"\" Gets or creates a topic. Args: topic_name: The name of the topic to create Returns: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError","title":"declare_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_queue","text":"Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : QueueWrapper ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError","title":"delete_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_topic","text":"Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : TopicWrapper ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"delete_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> QueueWrapper : \"\"\" Gets the queue with the name `queue_name`. Does not perform creation. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError","title":"get_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None Source code in melange/backends/interfaces.py def publish_to_topic ( self , message : Message , topic : TopicWrapper , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes a message content and the manifest to the topic Args: message: the message to send topic: the topic to send the message to extra_attributes: extra properties that might be required for the backend \"\"\" raise NotImplementedError","title":"publish_to_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : QueueWrapper , ** kwargs : Any ) -> List [ Message ]: \"\"\" Retrieves a list of available messages from the queue. Args: queue: the queue object **kwargs: Other parameters/options required by the backend Returns: A list of available messages from the queue \"\"\" raise NotImplementedError","title":"retrieve_messages()"},{"location":"components/publishers/","text":"Publishers Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics. Publishing to a queue Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application Publishing to a topic Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import TopicPublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishers"},{"location":"components/publishers/#publishers","text":"Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics.","title":"Publishers"},{"location":"components/publishers/#publishing-to-a-queue","text":"Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application","title":"Publishing to a queue"},{"location":"components/publishers/#publishing-to-a-topic","text":"Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import TopicPublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishing to a topic"},{"location":"components/serializers/","text":"Serializers Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list Creating your own serializers To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface: MessageSerializer ( Generic ) Base interface to inherit for all the serializers Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers \"\"\" def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object Source code in melange/serializers/interfaces.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object Source code in melange/serializers/interfaces.py def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"Serializers"},{"location":"components/serializers/#serializers","text":"Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list","title":"Serializers"},{"location":"components/serializers/#creating-your-own-serializers","text":"To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface:","title":"Creating your own serializers"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer","text":"Base interface to inherit for all the serializers Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers \"\"\" def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass","title":"MessageSerializer"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object Source code in melange/serializers/interfaces.py def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : \"\"\" Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Args: data: the data string to deserialize manifest: the manifest that corresponds to the serialized string Returns: The data object \"\"\" pass","title":"deserialize()"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object Source code in melange/serializers/interfaces.py def manifest ( self , data : T ) -> Optional [ str ]: \"\"\" Given an object which represents some data, return the manifest of that object (if any) Args: data: Returns: The manifest of the object \"\"\" return None","title":"manifest()"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation Args: data: the data object to serialize Returns: A string representation of the `data` object made with this serializer \"\"\" pass Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"serialize()"},{"location":"tutorial/getting-started/","text":"Tutorial - Getting started Talk is cheap, show me the code Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker. Choosing a Messaging Backend A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use LocalStack as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with a local SQS+SNS for development with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the LocalStack project to install it to your local machine. Though the quickest route is to launch the docker image with melange: docker-compose up This will start LocalStack in the port 4566 in localhost , ready to be used. Creating a queue Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" ) Publishing messages Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers. Consuming messages It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.doc_examples.tutorial.publish import MyTestMessage from melange.message_dispatcher import SimpleMessageDispatcher from melange.serializers.pickle import PickleSerializer class MyConsumer ( SingleDispatchConsumer ): @consumer def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () message_dispatcher = SimpleMessageDispatcher ( consumer , serializer , backend = backend , ) print ( \"Consuming...\" ) message_dispatcher . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py ) Where to go from here Now that you grasped the basic idea on how you could use Melange, you could go further and read more details about: Consumers Publishers Messaging Backend Serializers To add to that, although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#tutorial-getting-started","text":"Talk is cheap, show me the code Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker.","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#choosing-a-messaging-backend","text":"A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use LocalStack as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with a local SQS+SNS for development with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the LocalStack project to install it to your local machine. Though the quickest route is to launch the docker image with melange: docker-compose up This will start LocalStack in the port 4566 in localhost , ready to be used.","title":"Choosing a Messaging Backend"},{"location":"tutorial/getting-started/#creating-a-queue","text":"Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.backends.factory import MessagingBackendFactory backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" )","title":"Creating a queue"},{"location":"tutorial/getting-started/#publishing-messages","text":"Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers.","title":"Publishing messages"},{"location":"tutorial/getting-started/#consuming-messages","text":"It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.doc_examples.tutorial.publish import MyTestMessage from melange.message_dispatcher import SimpleMessageDispatcher from melange.serializers.pickle import PickleSerializer class MyConsumer ( SingleDispatchConsumer ): @consumer def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () message_dispatcher = SimpleMessageDispatcher ( consumer , serializer , backend = backend , ) print ( \"Consuming...\" ) message_dispatcher . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py )","title":"Consuming messages"},{"location":"tutorial/getting-started/#where-to-go-from-here","text":"Now that you grasped the basic idea on how you could use Melange, you could go further and read more details about: Consumers Publishers Messaging Backend Serializers To add to that, although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Where to go from here"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The spice must flow Melange is a python library/framework that abstracts a lot of the boilerplate that is usually required to implement a messaging infrastructure (commonly used to create distributed architectures and interact with microservices architectures). Out of the box Melange supports Amazon SQS + SNS, though the library is designed to be extensible, so that you can use it with your own messaging infrastructure, should you choose so. The interface this library offers is very clean and tries to tightly follow the best practices from Vaughn Vernon's book Implementing Domain-Driven Design as well as the recommended design patterns when dealing with messaging on distributed architectures. Installing pip install melange Documentation Full documentation is available at https://rydra.github.io/melange/ Examples The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service Why the name 'Melange' The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :) Project Links Docs: https://rydra.github.io/melange License MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"Melange"},{"location":"#installing","text":"pip install melange","title":"Installing"},{"location":"#documentation","text":"Full documentation is available at https://rydra.github.io/melange/","title":"Documentation"},{"location":"#examples","text":"The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service","title":"Examples"},{"location":"#why-the-name-melange","text":"The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :)","title":"Why the name 'Melange'"},{"location":"#project-links","text":"Docs: https://rydra.github.io/melange","title":"Project Links"},{"location":"#license","text":"MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"License"},{"location":"advanced-topics/","text":"Advanced Topics Registering the MessagingBackend globally To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . set_default_backend ( AWSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. Usage of the backend manager from melange.backends.backend_manager import BackendManager from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . set_default_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects. Message de-duplication Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a cache interface that you can supply to the ConsumerHandler (like a Redis cache ) that will control that no message is delivered twice to the same consumer. In Melange we provide a RedisCache class that you could use to perform this message deduplication. However we do not want to tie the library to any specific technology, so as long as you comply with the DeduplicationCache interface it will work just fine. The cache for message deduplication is completely optional, but on a production environment having some kind of cache to handle deduplication is encouraged. This is the DeduplicationCache specification: __contains__ ( self , key ) special Checks whether a certain key is present in the store Parameters: Name Type Description Default key str the key to check required Returns: Type Description bool True if the value is present, False otherwise. get ( self , key ) Retrieves the value stored under a key Parameters: Name Type Description Default key str the key to fetch in the cache required Returns: Type Description Any The value stored under that key, or None store ( self , key , value , expire = None ) Stores a key into the cache Parameters: Name Type Description Default key str required value Any required expire Optional[int] expiration time in seconds None","title":"Advanced topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#registering-the-messagingbackend-globally","text":"To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . set_default_backend ( AWSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. Usage of the backend manager from melange.backends.backend_manager import BackendManager from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . set_default_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects.","title":"Registering the MessagingBackend globally"},{"location":"advanced-topics/#message-de-duplication","text":"Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a cache interface that you can supply to the ConsumerHandler (like a Redis cache ) that will control that no message is delivered twice to the same consumer. In Melange we provide a RedisCache class that you could use to perform this message deduplication. However we do not want to tie the library to any specific technology, so as long as you comply with the DeduplicationCache interface it will work just fine. The cache for message deduplication is completely optional, but on a production environment having some kind of cache to handle deduplication is encouraged. This is the DeduplicationCache specification:","title":"Message de-duplication"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.__contains__","text":"Checks whether a certain key is present in the store Parameters: Name Type Description Default key str the key to check required Returns: Type Description bool True if the value is present, False otherwise.","title":"__contains__()"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.get","text":"Retrieves the value stored under a key Parameters: Name Type Description Default key str the key to fetch in the cache required Returns: Type Description Any The value stored under that key, or None","title":"get()"},{"location":"advanced-topics/#melange.infrastructure.cache.DeduplicationCache.store","text":"Stores a key into the cache Parameters: Name Type Description Default key str required value Any required expire Optional[int] expiration time in seconds None","title":"store()"},{"location":"behind-scenes/","text":"Behind the scenes How are messages serialized Messages, when serialized, they have the shape of a string. Some serializing formats might not require anything more that the message itself (like pickle). The message itself contains headers of some kind that tells deserializers how they have to deserialize that message (assuming you already know you always have to use that specific serializer). Other formats (like protobuf) require some kind of specification that tells the consumers how the message needs to be deserialized. This is why manifests exist and are necessary. A manifest tells the aplicacion which shape (manifestation) an array of bytes or a string had. This way we can appropriately choose the serializer that is able to properly deserialize the message. Imagine we want to serialize an object with a serializer that performs encryption as well: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ If we just sent that string to an outsider, how does it know that is a ProductCreated which has been serialized with a special serializer? However, with the aid of the manifest, we can give some clue to the deserializer on how that message was serialized: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ manifest = serializer . manifest ( event ) # manifest could be something like `mycryptoserializer:sha1:ProductCreated` That way we tell the consumer who has to deserialize the message that the message was serialized with the MyCryptographicSerializer , with a SHA1 algorithm, and that it is a ProductCreated event. The publishers, when sending the message, they send the manifest as well as the serialized message to provide the consumers with this valuable information. The manifest could be sent through the means of metadata (if your messaging infrastructure supports it) or through any other means that could be retrieved by the consumer.","title":"Behind the scenes"},{"location":"behind-scenes/#behind-the-scenes","text":"","title":"Behind the scenes"},{"location":"behind-scenes/#how-are-messages-serialized","text":"Messages, when serialized, they have the shape of a string. Some serializing formats might not require anything more that the message itself (like pickle). The message itself contains headers of some kind that tells deserializers how they have to deserialize that message (assuming you already know you always have to use that specific serializer). Other formats (like protobuf) require some kind of specification that tells the consumers how the message needs to be deserialized. This is why manifests exist and are necessary. A manifest tells the aplicacion which shape (manifestation) an array of bytes or a string had. This way we can appropriately choose the serializer that is able to properly deserialize the message. Imagine we want to serialize an object with a serializer that performs encryption as well: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ If we just sent that string to an outsider, how does it know that is a ProductCreated which has been serialized with a special serializer? However, with the aid of the manifest, we can give some clue to the deserializer on how that message was serialized: @dataclass class ProductCreated : id : int name : str event = ProductCreated ( 1 , \"Banana\" ) serialzer = MyCryptographicSerializer () serialized_event = serializer . serialize ( event ) # Let's say `serialized_event` has this content: # a&/(67567ulmtensr/((&/...29747JJJ manifest = serializer . manifest ( event ) # manifest could be something like `mycryptoserializer:sha1:ProductCreated` That way we tell the consumer who has to deserialize the message that the message was serialized with the MyCryptographicSerializer , with a SHA1 algorithm, and that it is a ProductCreated event. The publishers, when sending the message, they send the manifest as well as the serialized message to provide the consumers with this valuable information. The manifest could be sent through the means of metadata (if your messaging infrastructure supports it) or through any other means that could be retrieved by the consumer.","title":"How are messages serialized"},{"location":"examples/","text":"Examples Here are listed some relevant examples that you can find in the source code of Melange, alongside some explanation. The MessagingBackend used for all the examples is the LocalSQSBackend , though you could use your own. Personally what I do is to spin up a docker-compose process and then run the examples. Payment Service Example source This is the Melange/python version of the Order/Payment service that is being implemented in the video series SAGA Choreography Implementation . The example corresponds to a payment service that listens to a queue that receives events from an order service (which might come from another external service) and then those events are consumed to perform more logic. How to run the example: Run make run-example-app . This will start the consumer. On another terminal, run make run-example-triggerer reference=\"SOMEREFNUMBER\" Each time you run the triggerer, you should see a message like Order SOMEREFNUMBER paid successfully pop, meaning that the message was received successfully. SAGA Choreography Example source In this example we will see one powerful usage of melange in the form of a mix of saga orchestration/choreography. We will run a SAGA service that will manage the entire order processing service, and deliver the messages to the appropriate services to run what could be a fully distributed application. How to run the example. Run make run-example-app to start up the consumer for the payment service. Run make run-example-saga to start up the consumer for the saga orchestrator. On another terminal, run make run-example-saga-triggerer reference=\"SOMEREFNUMBER\" What you should see once you run the triggerer is, on the payment service consumer screen, the confirmation that the order was paid and immediately afterwards, on the saga orchestrator screen, the message that the order was paid and marked as complete. Congratulations on running your first web of microservices, connected by a messaging broker with passing messages!","title":"Examples"},{"location":"examples/#examples","text":"Here are listed some relevant examples that you can find in the source code of Melange, alongside some explanation. The MessagingBackend used for all the examples is the LocalSQSBackend , though you could use your own. Personally what I do is to spin up a docker-compose process and then run the examples.","title":"Examples"},{"location":"examples/#payment-service","text":"Example source This is the Melange/python version of the Order/Payment service that is being implemented in the video series SAGA Choreography Implementation . The example corresponds to a payment service that listens to a queue that receives events from an order service (which might come from another external service) and then those events are consumed to perform more logic. How to run the example: Run make run-example-app . This will start the consumer. On another terminal, run make run-example-triggerer reference=\"SOMEREFNUMBER\" Each time you run the triggerer, you should see a message like Order SOMEREFNUMBER paid successfully pop, meaning that the message was received successfully.","title":"Payment Service"},{"location":"examples/#saga-choreography","text":"Example source In this example we will see one powerful usage of melange in the form of a mix of saga orchestration/choreography. We will run a SAGA service that will manage the entire order processing service, and deliver the messages to the appropriate services to run what could be a fully distributed application. How to run the example. Run make run-example-app to start up the consumer for the payment service. Run make run-example-saga to start up the consumer for the saga orchestrator. On another terminal, run make run-example-saga-triggerer reference=\"SOMEREFNUMBER\" What you should see once you run the triggerer is, on the payment service consumer screen, the confirmation that the order was paid and immediately afterwards, on the saga orchestrator screen, the message that the order was paid and marked as complete. Congratulations on running your first web of microservices, connected by a messaging broker with passing messages!","title":"SAGA Choreography"},{"location":"factory/","text":"Factory Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform. Creating a queue Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" ) Creating a topic Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.sqs_backend import AWSBackend backend = AWSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" ) Creating a queue and subscribing it to several topics You could create a queue and immediately subscribe it to a number of topics: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , [ \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" ], dead_letter_queue_name = \"payment-updates.fifo\" , ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Factory"},{"location":"factory/#factory","text":"Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform.","title":"Factory"},{"location":"factory/#creating-a-queue","text":"Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" )","title":"Creating a queue"},{"location":"factory/#creating-a-topic","text":"Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.sqs_backend import AWSBackend backend = AWSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" )","title":"Creating a topic"},{"location":"factory/#creating-a-queue-and-subscribing-it-to-several-topics","text":"You could create a queue and immediately subscribe it to a number of topics: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , [ \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" ], dead_letter_queue_name = \"payment-updates.fifo\" , ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Creating a queue and subscribing it to several topics"},{"location":"mixed-bag/","text":"Mixed bag of ideas Interesting links and articles Effective aggregate design by Vaughn Vernon Domain Events - Salvation by Udi Dahan Test structure in python : I really liked this article, it inspired me to restructure Melange a bit.","title":"Mixed bag of ideas"},{"location":"mixed-bag/#mixed-bag-of-ideas","text":"","title":"Mixed bag of ideas"},{"location":"mixed-bag/#interesting-links-and-articles","text":"Effective aggregate design by Vaughn Vernon Domain Events - Salvation by Udi Dahan Test structure in python : I really liked this article, it inspired me to restructure Melange a bit.","title":"Interesting links and articles"},{"location":"roadmap/","text":"Roadmap Multiple serializers Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept . Kombu integration Maybe The Messaging Backends could be entirely replaced with Kombu, since kombu already offers an abstraction layer over several messaging brokers. Undergo some kind of proof of concept to see if such a thing is possible and how. Kafka integration Kafka is a powerful messaging broker technology that covers lots of features and functionalities that could provide some ideas to the current features that melange provides.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#multiple-serializers","text":"Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept .","title":"Multiple serializers"},{"location":"roadmap/#kombu-integration","text":"Maybe The Messaging Backends could be entirely replaced with Kombu, since kombu already offers an abstraction layer over several messaging brokers. Undergo some kind of proof of concept to see if such a thing is possible and how.","title":"Kombu integration"},{"location":"roadmap/#kafka-integration","text":"Kafka is a powerful messaging broker technology that covers lots of features and functionalities that could provide some ideas to the current features that melange provides.","title":"Kafka integration"},{"location":"testing/","text":"Testing Any developer worth its salt does some kind of testing over the code they develop. However, testing software that spans several processes/threads (like when you do pub/sub over a queue/topic) can be a daunting task. Melange offers several utilities to help you test your publishers and consumers (or just making everything synchronous inside the context of the test for the sake of simplicity). Here some examples are presented on how you could potentially use the library in your tests. Asynchronous testing with threads Follow the next steps whenever you need to have one or more consumers running on the background of your test: Make sure to create (or ensure that they exist at least) the queues and topics where the message exchange happens. Start the consumer loop in a separate thread, and make sure the thread is stopped upon termination of the test. Call your code that invokes the publishing methods, and have probes in place that poll the environment to check whether the consumers have done their work or not before doing any kind of assertion that requires of the consumers' results. Bonus: After the test is finished, delete the queue/topic to keep the environment clean. Full Example: Asynchronous testing with probes and threads import os import threading from dataclasses import dataclass from typing import Dict , Optional import polling from hamcrest import * from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import Consumer from melange.message_dispatcher import SimpleMessageDispatcher from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer from tests.probe import Probe class StateProbe ( Probe ): def __init__ ( self , state : \"State\" ) -> None : self . state = state def sample ( self ) -> None : pass def can_be_measured ( self ) -> bool : self . sample () return self . state . value_set is not None def wait ( self ) -> None : try : polling . poll ( self . can_be_measured , 1 , timeout = 60 ) except polling . TimeoutException as e : raise Exception ( \"Timeout!\" ) from e @dataclass class State : value_set : Optional [ int ] = None def test_async_consumer ( request ): serializer = PickleSerializer () # We'll use the ElasticMQ as backend since it works like a real SQS queue backend = LocalSQSBackend ( host = os . environ . get ( \"SQSHOST\" ), port = os . environ . get ( \"SQSPORT\" ) ) queue_name = \"testqueue\" # Initialize the queue queue = MessagingBackendFactory ( backend ) . init_queue ( queue_name ) # Delete the queue upon finishing the execution of the test def teardown (): backend . delete_queue ( queue ) request . addfinalizer ( teardown ) # Create a consumer that, upon receiving a message, will set # the variable \"value set\" to later assert that this value # has, indeed, been set by the consumer that is running on another thread state = State () def set_state ( message : Dict ) -> None : state . value_set = message [ \"value\" ] consumer = Consumer ( on_message = set_state ) handler = SimpleMessageDispatcher ( consumer , serializer , backend = backend ) # Start the consumer loop thread to run the consumer loop in the background threading . Thread ( target = lambda : handler . consume_loop ( queue_name ), daemon = True ) . start () # Publish a message and... publisher = QueuePublisher ( serializer , backend ) publisher . publish ( queue_name , { \"value\" : 1 }) # ...wait until the value is set probe = StateProbe ( state ) probe . wait () assert_that ( state . value_set , is_ ( 1 )) This kind of test has the advantage of being very explicit in the sense that it expresses, through the probe, that this test has some asynchronous processing in the background, and waits for it. It's quite realistic as well, pub/sub is asynchronous in its nature and we work with it in this test. However the arrangement is complex. It's a trade-off between completeness and complexity that you have to embrace if you want to follow this route. TIP: Try to abstract away all this arrangement code from the main body of the test to keep it clean and clear, avoiding pollution. Testing frameworks have different techniques to abstract away arrangements (like pytest fixtures). Synchronous testing with the InMemoryMessagingBackend Another option is to use the bundled InMemoryMessagingBackend when instantiating your publishers and consumers. This will make the entirety of the test synchronous in respect to the message passing. Synchronous testing with the InMemoryMessagingBackend from melange.backends.testing import InMemoryMessagingBackend , link_synchronously from melange.consumers import Consumer from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer def test_inmemory_messaging_backend (): consumer_1 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } !\" )) consumer_2 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } 2!\" )) serializer = PickleSerializer () backend = InMemoryMessagingBackend () link_synchronously ( \"somequeue\" , [ consumer_1 , consumer_2 ], serializer , backend ) publisher = QueuePublisher ( PickleSerializer (), backend = backend ) publisher . publish ( \"somequeue\" , { \"message\" : \"Mary\" }) What the InMemoryMessagingBackend does, upon publish, is to store the serialized message in memory and forward it to the internal consumer dispatcher, so that the consumers can synchronously receive and process the message. The link_synchronously function is a helper which glues everything together. All the messages sent to the queue or topic with that name will be dispatched to those consumers (if the consumers accept that message).","title":"Testing"},{"location":"testing/#testing","text":"Any developer worth its salt does some kind of testing over the code they develop. However, testing software that spans several processes/threads (like when you do pub/sub over a queue/topic) can be a daunting task. Melange offers several utilities to help you test your publishers and consumers (or just making everything synchronous inside the context of the test for the sake of simplicity). Here some examples are presented on how you could potentially use the library in your tests.","title":"Testing"},{"location":"testing/#asynchronous-testing-with-threads","text":"Follow the next steps whenever you need to have one or more consumers running on the background of your test: Make sure to create (or ensure that they exist at least) the queues and topics where the message exchange happens. Start the consumer loop in a separate thread, and make sure the thread is stopped upon termination of the test. Call your code that invokes the publishing methods, and have probes in place that poll the environment to check whether the consumers have done their work or not before doing any kind of assertion that requires of the consumers' results. Bonus: After the test is finished, delete the queue/topic to keep the environment clean. Full Example: Asynchronous testing with probes and threads import os import threading from dataclasses import dataclass from typing import Dict , Optional import polling from hamcrest import * from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import Consumer from melange.message_dispatcher import SimpleMessageDispatcher from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer from tests.probe import Probe class StateProbe ( Probe ): def __init__ ( self , state : \"State\" ) -> None : self . state = state def sample ( self ) -> None : pass def can_be_measured ( self ) -> bool : self . sample () return self . state . value_set is not None def wait ( self ) -> None : try : polling . poll ( self . can_be_measured , 1 , timeout = 60 ) except polling . TimeoutException as e : raise Exception ( \"Timeout!\" ) from e @dataclass class State : value_set : Optional [ int ] = None def test_async_consumer ( request ): serializer = PickleSerializer () # We'll use the ElasticMQ as backend since it works like a real SQS queue backend = LocalSQSBackend ( host = os . environ . get ( \"SQSHOST\" ), port = os . environ . get ( \"SQSPORT\" ) ) queue_name = \"testqueue\" # Initialize the queue queue = MessagingBackendFactory ( backend ) . init_queue ( queue_name ) # Delete the queue upon finishing the execution of the test def teardown (): backend . delete_queue ( queue ) request . addfinalizer ( teardown ) # Create a consumer that, upon receiving a message, will set # the variable \"value set\" to later assert that this value # has, indeed, been set by the consumer that is running on another thread state = State () def set_state ( message : Dict ) -> None : state . value_set = message [ \"value\" ] consumer = Consumer ( on_message = set_state ) handler = SimpleMessageDispatcher ( consumer , serializer , backend = backend ) # Start the consumer loop thread to run the consumer loop in the background threading . Thread ( target = lambda : handler . consume_loop ( queue_name ), daemon = True ) . start () # Publish a message and... publisher = QueuePublisher ( serializer , backend ) publisher . publish ( queue_name , { \"value\" : 1 }) # ...wait until the value is set probe = StateProbe ( state ) probe . wait () assert_that ( state . value_set , is_ ( 1 )) This kind of test has the advantage of being very explicit in the sense that it expresses, through the probe, that this test has some asynchronous processing in the background, and waits for it. It's quite realistic as well, pub/sub is asynchronous in its nature and we work with it in this test. However the arrangement is complex. It's a trade-off between completeness and complexity that you have to embrace if you want to follow this route. TIP: Try to abstract away all this arrangement code from the main body of the test to keep it clean and clear, avoiding pollution. Testing frameworks have different techniques to abstract away arrangements (like pytest fixtures).","title":"Asynchronous testing with threads"},{"location":"testing/#synchronous-testing-with-the-inmemorymessagingbackend","text":"Another option is to use the bundled InMemoryMessagingBackend when instantiating your publishers and consumers. This will make the entirety of the test synchronous in respect to the message passing. Synchronous testing with the InMemoryMessagingBackend from melange.backends.testing import InMemoryMessagingBackend , link_synchronously from melange.consumers import Consumer from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer def test_inmemory_messaging_backend (): consumer_1 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } !\" )) consumer_2 = Consumer ( lambda message : print ( f \"Hello { message [ 'message' ] } 2!\" )) serializer = PickleSerializer () backend = InMemoryMessagingBackend () link_synchronously ( \"somequeue\" , [ consumer_1 , consumer_2 ], serializer , backend ) publisher = QueuePublisher ( PickleSerializer (), backend = backend ) publisher . publish ( \"somequeue\" , { \"message\" : \"Mary\" }) What the InMemoryMessagingBackend does, upon publish, is to store the serialized message in memory and forward it to the internal consumer dispatcher, so that the consumers can synchronously receive and process the message. The link_synchronously function is a helper which glues everything together. All the messages sent to the queue or topic with that name will be dispatched to those consumers (if the consumers accept that message).","title":"Synchronous testing with the InMemoryMessagingBackend"},{"location":"api-reference/consumers/","text":"Consumers Consumer A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a on_message callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the process and accepts methods. accepts ( self , manifest ) Determines whether it is able to handle a message or not process ( self , message , ** kwargs ) Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {} SingleDispatchConsumer ( Consumer , SingleDispatch ) This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method accepts ( self , message ) Determines whether it is able to handle a message or not process ( self , message , ** kwargs ) Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {}","title":"Consumers"},{"location":"api-reference/consumers/#consumers","text":"","title":"Consumers"},{"location":"api-reference/consumers/#melange.consumers.Consumer","text":"A consumer is responsible to process a message and do whatever is needed by the application. You could use is as is and supply a on_message callable to process your messages. Though commonly you would inherit this class, create your own consumer and override the process and accepts methods.","title":"Consumer"},{"location":"api-reference/consumers/#melange.consumers.Consumer.accepts","text":"Determines whether it is able to handle a message or not","title":"accepts()"},{"location":"api-reference/consumers/#melange.consumers.Consumer.process","text":"Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {}","title":"process()"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer","text":"This class can consume events from a queue and pass them to a processor through the means of method overloading. Provides a default implementation as well for the accepts method","title":"SingleDispatchConsumer"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer.accepts","text":"Determines whether it is able to handle a message or not","title":"accepts()"},{"location":"api-reference/consumers/#melange.consumers.SingleDispatchConsumer.process","text":"Processes a message Parameters: Name Type Description Default message Any the message data to process, already deserialied required **kwargs Any any other parameters the dispatcher sends upon processing {}","title":"process()"},{"location":"api-reference/factory/","text":"Messaging Backend Factory MessagingBackendFactory Class used to create queues and topics init_queue ( self , queue_name , topic_names_to_subscribe = None , dlq_name = None , ** kwargs ) Creates a queue if it does not exist, subscribes it to the topics, and creates a dead letter queue. Parameters: Name Type Description Default queue_name str name of the queue to create required topic_names_to_subscribe Optional[List[str]] list of topic names to subscribe this queue. If the topics do not exist they will be created. None dlq_name Optional[str] name of the dead letter queue to create and attach to the main queue None **kwargs Any any other arguments required by your messaging backend {} Returns: Type Description QueueWrapper The created queue wrapper init_topic ( self , topic_name ) Creates a topic if it does not exist. Parameters: Name Type Description Default topic_name str the name of the topic to create required Returns: Type Description TopicWrapper The created topic wrapper","title":"Factory"},{"location":"api-reference/factory/#messaging-backend-factory","text":"","title":"Messaging Backend Factory"},{"location":"api-reference/factory/#melange.backends.factory.MessagingBackendFactory","text":"Class used to create queues and topics","title":"MessagingBackendFactory"},{"location":"api-reference/factory/#melange.backends.factory.MessagingBackendFactory.init_queue","text":"Creates a queue if it does not exist, subscribes it to the topics, and creates a dead letter queue. Parameters: Name Type Description Default queue_name str name of the queue to create required topic_names_to_subscribe Optional[List[str]] list of topic names to subscribe this queue. If the topics do not exist they will be created. None dlq_name Optional[str] name of the dead letter queue to create and attach to the main queue None **kwargs Any any other arguments required by your messaging backend {} Returns: Type Description QueueWrapper The created queue wrapper","title":"init_queue()"},{"location":"api-reference/factory/#melange.backends.factory.MessagingBackendFactory.init_topic","text":"Creates a topic if it does not exist. Parameters: Name Type Description Default topic_name str the name of the topic to create required Returns: Type Description TopicWrapper The created topic wrapper","title":"init_topic()"},{"location":"api-reference/messaging-backends/","text":"Messaging Backends MessagingBackend acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required delete_queue ( self , queue ) Deletes the queue delete_topic ( self , topic ) Deletes the topic get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue BackendManager get_default_backend ( self ) Returns the current default backend set_default_backend ( self , backend ) Sets the default backend Parameters: Name Type Description Default backend MessagingBackend required AWSBackend ( BaseSQSBackend ) Backend to use with AWS BaseSQSBackend ( MessagingBackend ) Base class for SQS Backends acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required delete_queue ( self , queue ) Deletes the queue delete_topic ( self , topic ) Deletes the topic get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue","title":"Messaging Backends"},{"location":"api-reference/messaging-backends/#messaging-backends","text":"","title":"Messaging Backends"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend","text":"","title":"MessagingBackend"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future","title":"acknowledge()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way","title":"close_connection()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies)","title":"declare_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required","title":"declare_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_queue","text":"Deletes the queue","title":"delete_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_topic","text":"Deletes the topic","title":"delete_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue","title":"get_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None","title":"publish_to_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.interfaces.MessagingBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue","title":"retrieve_messages()"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager","text":"","title":"BackendManager"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager.get_default_backend","text":"Returns the current default backend","title":"get_default_backend()"},{"location":"api-reference/messaging-backends/#melange.backends.backend_manager.BackendManager.set_default_backend","text":"Sets the default backend Parameters: Name Type Description Default backend MessagingBackend required","title":"set_default_backend()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.AWSBackend","text":"Backend to use with AWS","title":"AWSBackend"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend","text":"Base class for SQS Backends","title":"BaseSQSBackend"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future","title":"acknowledge()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way","title":"close_connection()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies)","title":"declare_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required","title":"declare_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.delete_queue","text":"Deletes the queue","title":"delete_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.delete_topic","text":"Deletes the topic","title":"delete_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue","title":"get_queue()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None","title":"publish_to_topic()"},{"location":"api-reference/messaging-backends/#melange.backends.sqs.sqs_backend.BaseSQSBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue","title":"retrieve_messages()"},{"location":"api-reference/publishers/","text":"Publishers QueuePublisher publish ( self , queue_name , data , ** kwargs ) Publishes data to a queue Parameters: Name Type Description Default queue_name str The queue to send the message to. required data Any The data to send to this queue. It will be serialized before sending to the queue using the serializers. required **kwargs Any Any extra attributes. They will be passed to the backend upon publish. {} TopicPublisher publish ( self , topic_name , data , ** extra_attributes ) Publishes data to a topic Parameters: Name Type Description Default topic_name str The topic to send the message to. required data Any The data to send to this topic. It will be serialized before sending to the topic using the serializers. required **extra_attributes Any Any extra attributes. They will be passed to the backend upon publishing. {}","title":"Publishers"},{"location":"api-reference/publishers/#publishers","text":"","title":"Publishers"},{"location":"api-reference/publishers/#melange.publishers.QueuePublisher","text":"","title":"QueuePublisher"},{"location":"api-reference/publishers/#melange.publishers.QueuePublisher.publish","text":"Publishes data to a queue Parameters: Name Type Description Default queue_name str The queue to send the message to. required data Any The data to send to this queue. It will be serialized before sending to the queue using the serializers. required **kwargs Any Any extra attributes. They will be passed to the backend upon publish. {}","title":"publish()"},{"location":"api-reference/publishers/#melange.publishers.TopicPublisher","text":"","title":"TopicPublisher"},{"location":"api-reference/publishers/#melange.publishers.TopicPublisher.publish","text":"Publishes data to a topic Parameters: Name Type Description Default topic_name str The topic to send the message to. required data Any The data to send to this topic. It will be serialized before sending to the topic using the serializers. required **extra_attributes Any Any extra attributes. They will be passed to the backend upon publishing. {}","title":"publish()"},{"location":"api-reference/serializers/","text":"Serializers MessageSerializer ( Generic ) Base interface to inherit for all the serializers deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer JsonSerializer ( MessageSerializer ) Serializes and deserializes python dictionaries in json format deserialize ( self , serialized_data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description Dict The data object manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data Dict required Returns: Type Description str The manifest of the object serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data Dict the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer PickleSerializer ( MessageSerializer ) Serializes DomainEvents with pickle. deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description DomainEvent The data object manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data DomainEvent required Returns: Type Description str The manifest of the object serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data DomainEvent the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer","title":"Serializers"},{"location":"api-reference/serializers/#serializers","text":"","title":"Serializers"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer","text":"Base interface to inherit for all the serializers","title":"MessageSerializer"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.interfaces.MessageSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer","title":"serialize()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer","text":"Serializes and deserializes python dictionaries in json format","title":"JsonSerializer"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description Dict The data object","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data Dict required Returns: Type Description str The manifest of the object","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.json.JsonSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data Dict the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer","title":"serialize()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer","text":"Serializes DomainEvents with pickle.","title":"PickleSerializer"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description DomainEvent The data object","title":"deserialize()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data DomainEvent required Returns: Type Description str The manifest of the object","title":"manifest()"},{"location":"api-reference/serializers/#melange.serializers.pickle.PickleSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data DomainEvent the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer","title":"serialize()"},{"location":"components/consumers/","text":"Message Dispatchers and Consumers Message Dispatcher and Consumers are the counterpart of the publishers. Consumers attach themselves to a Message Dispatcher, and the message dispatchers start the consuming loop and receive the messages from a queue, forwarding them to a consumer that accepts that message. Consumers Consumers are very simple, since they only receive a Message as a parameter and then they do some kind of processing to send it down to the lower layers of your application (something like a REST view/controller). To mplement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method, and, optionally, the accepts method. Example (from examples/payment_service/consumer_draft.py ): from typing import Any , Optional from melange.consumers import Consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( Consumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service def process ( self , message : Any , ** kwargs : Any ) -> None : if isinstance ( message , OrderResponse ): self . payment_service . process ( message ) elif isinstance ( message , DoPayment ): self . payment_service . do_payment ( message ) def accepts ( self , manifest : Optional [ str ]) -> bool : return manifest in [ \"OrderResponse\" , \"DoPayment\" ] There is a variation of the Consumer , the SingleDispatchConsumer consumer. It relies on the singledispatch library to implement method overloading on the process function, in order to achieve a richer accepts and process methods. This has proven to make the development of complex consumers faster and cleaner. The same PaymentConsumer as above, but implemented by subclassing SingleDispatchConsumer (from examples/payment_service/consumer.py ): from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( SingleDispatchConsumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service @consumer def consume_order_response ( self , event : OrderResponse ) -> None : self . payment_service . process ( event ) @consumer def consume_do_payment ( self , command : DoPayment ) -> None : self . payment_service . do_payment ( command ) For a consumer to be able to receive messages it requires to be attached to a MessageDispatcher Message Dispatcher As summarized on top of this article, the MessageDispatcher component/class is the responsible to: Start the polling loop to get new messages through the MessagingBackend . Deserialize the message with the appropriate MessageSerializer . Pass the message to the consumers that accept it for further processing. Acknowledge the message. There is a variation of the MessageDispatcher called SimpleMessageDispatcher which is essentially the same as the former, but when you have only one consumer. This is the specification of the MessageDispatcher class: The MessageDispatcher is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers. attach_consumer ( self , consumer ) Attaches a consumer to the dispatcher, so that it can receive messages Parameters: Name Type Description Default consumer Consumer the consumer to attach required consume_event ( self , queue_name ) Consumes one event on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to consume from required consume_loop ( self , queue_name , on_exception = None , after_consume = None ) Starts the consumption loop on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to poll for new messages required on_exception Optional[Callable[[Exception], NoneType]] If there is any exception, the exception will be passed to this callback None after_consume Optional[Callable[[], NoneType]] After consuming a batch of events, invoke this callback None unattach_consumer ( self , consumer ) Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Parameters: Name Type Description Default consumer Consumer the consumer to unattach required NOTE: Unless the always_ack is set to True , a message will only be acknowleged if it's been correcly processed by all consumers that accept the message. Unless message deduplication is in place, if a consumers fails the same message is going to be reprocessed again by all the consumers, which can lead to issues. Either use only one consumer per MessageDispatcher , make your consumers idempotent, or set a DeduplicationCache when instantiating the MessageDispatcher .","title":"Message Dispatcher and Consumers"},{"location":"components/consumers/#message-dispatchers-and-consumers","text":"Message Dispatcher and Consumers are the counterpart of the publishers. Consumers attach themselves to a Message Dispatcher, and the message dispatchers start the consuming loop and receive the messages from a queue, forwarding them to a consumer that accepts that message.","title":"Message Dispatchers and Consumers"},{"location":"components/consumers/#consumers","text":"Consumers are very simple, since they only receive a Message as a parameter and then they do some kind of processing to send it down to the lower layers of your application (something like a REST view/controller). To mplement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method, and, optionally, the accepts method. Example (from examples/payment_service/consumer_draft.py ): from typing import Any , Optional from melange.consumers import Consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( Consumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service def process ( self , message : Any , ** kwargs : Any ) -> None : if isinstance ( message , OrderResponse ): self . payment_service . process ( message ) elif isinstance ( message , DoPayment ): self . payment_service . do_payment ( message ) def accepts ( self , manifest : Optional [ str ]) -> bool : return manifest in [ \"OrderResponse\" , \"DoPayment\" ] There is a variation of the Consumer , the SingleDispatchConsumer consumer. It relies on the singledispatch library to implement method overloading on the process function, in order to achieve a richer accepts and process methods. This has proven to make the development of complex consumers faster and cleaner. The same PaymentConsumer as above, but implemented by subclassing SingleDispatchConsumer (from examples/payment_service/consumer.py ): from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.common.commands import DoPayment from melange.examples.payment_service.events import OrderResponse from melange.examples.payment_service.service import PaymentService class PaymentConsumer ( SingleDispatchConsumer ): def __init__ ( self , payment_service : PaymentService ): super () . __init__ () self . payment_service = payment_service @consumer def consume_order_response ( self , event : OrderResponse ) -> None : self . payment_service . process ( event ) @consumer def consume_do_payment ( self , command : DoPayment ) -> None : self . payment_service . do_payment ( command ) For a consumer to be able to receive messages it requires to be attached to a MessageDispatcher","title":"Consumers"},{"location":"components/consumers/#message-dispatcher","text":"As summarized on top of this article, the MessageDispatcher component/class is the responsible to: Start the polling loop to get new messages through the MessagingBackend . Deserialize the message with the appropriate MessageSerializer . Pass the message to the consumers that accept it for further processing. Acknowledge the message. There is a variation of the MessageDispatcher called SimpleMessageDispatcher which is essentially the same as the former, but when you have only one consumer. This is the specification of the MessageDispatcher class: The MessageDispatcher is responsible to start the message consumption loop to retrieve the available messages from the queue and dispatch them to the consumers.","title":"Message Dispatcher"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.attach_consumer","text":"Attaches a consumer to the dispatcher, so that it can receive messages Parameters: Name Type Description Default consumer Consumer the consumer to attach required","title":"attach_consumer()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.consume_event","text":"Consumes one event on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to consume from required","title":"consume_event()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.consume_loop","text":"Starts the consumption loop on the queue queue_name Parameters: Name Type Description Default queue_name str The queue to poll for new messages required on_exception Optional[Callable[[Exception], NoneType]] If there is any exception, the exception will be passed to this callback None after_consume Optional[Callable[[], NoneType]] After consuming a batch of events, invoke this callback None","title":"consume_loop()"},{"location":"components/consumers/#melange.message_dispatcher.MessageDispatcher.unattach_consumer","text":"Unattaches the consumer from the dispatcher, so that it will not receive messages anymore Parameters: Name Type Description Default consumer Consumer the consumer to unattach required NOTE: Unless the always_ack is set to True , a message will only be acknowleged if it's been correcly processed by all consumers that accept the message. Unless message deduplication is in place, if a consumers fails the same message is going to be reprocessed again by all the consumers, which can lead to issues. Either use only one consumer per MessageDispatcher , make your consumers idempotent, or set a DeduplicationCache when instantiating the MessageDispatcher .","title":"unattach_consumer()"},{"location":"components/messaging-backends/","text":"Messaging backends A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The AWSBackend and the LocalSQSBackend . The RabbitMQBackend is present in the source code, but not actively maintained. Looking for contributors! Writing your own Messaging Backend Subclass the MessagingBackend interface and implement all the methods of that class. Here is the documentation of the interface class and all its methods. You need to take in mind, when implementing the methods that return a QueueWrapper or a TopicWrapper , to wrap inside them the real object that represents your queue or topic (in your chosen messaging technology) and unwrap it inside the messaging backend when requiring to perform specific operations. Look at the AWSBackend as a template/example of this wrapping/unwrapping. MessagingBackend acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies) declare_topic ( self , topic_name ) Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required delete_queue ( self , queue ) Deletes the queue delete_topic ( self , topic ) Deletes the topic get_queue ( self , queue_name ) Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue publish_to_topic ( self , message , topic , extra_attributes = None ) Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None retrieve_messages ( self , queue , ** kwargs ) Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue","title":"Messaging Backends"},{"location":"components/messaging-backends/#messaging-backends","text":"A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The AWSBackend and the LocalSQSBackend . The RabbitMQBackend is present in the source code, but not actively maintained. Looking for contributors!","title":"Messaging backends"},{"location":"components/messaging-backends/#writing-your-own-messaging-backend","text":"Subclass the MessagingBackend interface and implement all the methods of that class. Here is the documentation of the interface class and all its methods. You need to take in mind, when implementing the methods that return a QueueWrapper or a TopicWrapper , to wrap inside them the real object that represents your queue or topic (in your chosen messaging technology) and unwrap it inside the messaging backend when requiring to perform specific operations. Look at the AWSBackend as a template/example of this wrapping/unwrapping.","title":"Writing your own Messaging Backend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend","text":"","title":"MessagingBackend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future","title":"acknowledge()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way","title":"close_connection()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_queue","text":"Gets or creates a queue. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind TopicWrapper if provided, creates all these topics and subscribes the created queue to them () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to the created queue_name . None **kwargs Any {} Returns: Type Description Tuple[melange.models.QueueWrapper, Optional[melange.models.QueueWrapper]] A tuple with the created queue and the dead letter queue (if applies)","title":"declare_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_topic","text":"Gets or creates a topic. Parameters: Name Type Description Default topic_name str The name of the topic to create required Returns: Type Description TopicWrapper An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required","title":"declare_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_queue","text":"Deletes the queue","title":"delete_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_topic","text":"Deletes the topic","title":"delete_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.get_queue","text":"Gets the queue with the name queue_name . Does not perform creation. Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description QueueWrapper A Queue object that represents the created the queue","title":"get_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.publish_to_topic","text":"Publishes a message content and the manifest to the topic Parameters: Name Type Description Default message Message the message to send required topic TopicWrapper the topic to send the message to required extra_attributes Optional[Dict] extra properties that might be required for the backend None","title":"publish_to_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.retrieve_messages","text":"Retrieves a list of available messages from the queue. Parameters: Name Type Description Default queue QueueWrapper the queue object required **kwargs Any Other parameters/options required by the backend {} Returns: Type Description List[melange.models.Message] A list of available messages from the queue","title":"retrieve_messages()"},{"location":"components/publishers/","text":"Publishers Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics. Publishing to a queue Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application Publishing to a topic Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import TopicPublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishers"},{"location":"components/publishers/#publishers","text":"Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics.","title":"Publishers"},{"location":"components/publishers/#publishing-to-a-queue","text":"Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application","title":"Publishing to a queue"},{"location":"components/publishers/#publishing-to-a-topic","text":"Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import TopicPublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishing to a topic"},{"location":"components/serializers/","text":"Serializers Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list Creating your own serializers To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface: MessageSerializer ( Generic ) Base interface to inherit for all the serializers deserialize ( self , data , manifest = None ) Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object manifest ( self , data ) Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object serialize ( self , data ) Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"Serializers"},{"location":"components/serializers/#serializers","text":"Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list","title":"Serializers"},{"location":"components/serializers/#creating-your-own-serializers","text":"To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface:","title":"Creating your own serializers"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer","text":"Base interface to inherit for all the serializers","title":"MessageSerializer"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.deserialize","text":"Deserializes a data string. The manifest helps the serializer by providing information on how this object must be deserialized. Parameters: Name Type Description Default data str the data string to deserialize required manifest Optional[str] the manifest that corresponds to the serialized string None Returns: Type Description ~T The data object","title":"deserialize()"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.manifest","text":"Given an object which represents some data, return the manifest of that object (if any) Parameters: Name Type Description Default data ~T required Returns: Type Description Optional[str] The manifest of the object","title":"manifest()"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.serialize","text":"Serializes and object to a string representation Parameters: Name Type Description Default data ~T the data object to serialize required Returns: Type Description str A string representation of the data object made with this serializer Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"serialize()"},{"location":"tutorial/getting-started/","text":"Tutorial - Getting started Talk is cheap, show me the code Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker. Choosing a Messaging Backend A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use LocalStack as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with a local SQS+SNS for development with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the LocalStack project to install it to your local machine. Though the quickest route is to launch the docker image with melange: docker-compose up This will start LocalStack in the port 4566 in localhost , ready to be used. Creating a queue Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" ) Publishing messages Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers. Consuming messages It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.doc_examples.tutorial.publish import MyTestMessage from melange.message_dispatcher import SimpleMessageDispatcher from melange.serializers.pickle import PickleSerializer class MyConsumer ( SingleDispatchConsumer ): @consumer def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () message_dispatcher = SimpleMessageDispatcher ( consumer , serializer , backend = backend , ) print ( \"Consuming...\" ) message_dispatcher . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py ) Where to go from here Now that you grasped the basic idea on how you could use Melange, you could go further and read more details about: Consumers Publishers Messaging Backend Serializers To add to that, although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#tutorial-getting-started","text":"Talk is cheap, show me the code Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker.","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#choosing-a-messaging-backend","text":"A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use LocalStack as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with a local SQS+SNS for development with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the LocalStack project to install it to your local machine. Though the quickest route is to launch the docker image with melange: docker-compose up This will start LocalStack in the port 4566 in localhost , ready to be used.","title":"Choosing a Messaging Backend"},{"location":"tutorial/getting-started/#creating-a-queue","text":"Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.factory import MessagingBackendFactory from melange.backends.sqs.localsqs import LocalSQSBackend backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" )","title":"Creating a queue"},{"location":"tutorial/getting-started/#publishing-messages","text":"Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.backends.sqs.localsqs import LocalSQSBackend from melange.publishers import QueuePublisher from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers.","title":"Publishing messages"},{"location":"tutorial/getting-started/#consuming-messages","text":"It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.backends.sqs.localsqs import LocalSQSBackend from melange.consumers import SingleDispatchConsumer , consumer from melange.examples.doc_examples.tutorial.publish import MyTestMessage from melange.message_dispatcher import SimpleMessageDispatcher from melange.serializers.pickle import PickleSerializer class MyConsumer ( SingleDispatchConsumer ): @consumer def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = LocalSQSBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () message_dispatcher = SimpleMessageDispatcher ( consumer , serializer , backend = backend , ) print ( \"Consuming...\" ) message_dispatcher . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py )","title":"Consuming messages"},{"location":"tutorial/getting-started/#where-to-go-from-here","text":"Now that you grasped the basic idea on how you could use Melange, you could go further and read more details about: Consumers Publishers Messaging Backend Serializers To add to that, although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Where to go from here"}]}
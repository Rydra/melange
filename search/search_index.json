{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The spice must flow Melange is a python library/framework that abstracts a lot of the boilerplate that is usually required to implement a messaging infrastructure (commonly used to create distributed architectures and interact with microservices architectures). Out of the box Melange supports Amazon SQS, SNS and RabbitMQ, though the library is designed to be extensible, so that you can use it with your own messaging infrastructure, should you choose so. The interface this library offers is very clean and tries to tightly follow the best practices from Vaughn Vernon's book Implementing Domain-Driven Design as well as the recommended design patterns when dealing with messaging on distributed architectures. Installing pip install melange Documentation Full documentation is available at https://rydra.github.io/melange/ Examples The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service Why the name 'Melange' The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :) Contributing We're open to contributions and opinions! Project Links Docs: https://rydra.github.io/melange License MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"Melange"},{"location":"#installing","text":"pip install melange","title":"Installing"},{"location":"#documentation","text":"Full documentation is available at https://rydra.github.io/melange/","title":"Documentation"},{"location":"#examples","text":"The code base features several full-fledged examples that covers some complex use cases: Saga choreography in action Payment service","title":"Examples"},{"location":"#why-the-name-melange","text":"The name \"Melange\" is a reference to the drug-spice from the sci-fi book saga \"Dune\", a spice which is only generated in a single planet in the universe (planet Dune) and every human depends on it. If the spice flows, then the spice can be controlled. He who controls the spice, controls the universe. The spice must flow. The analogy can be very well made on Events in a distributed architecture :)","title":"Why the name 'Melange'"},{"location":"#contributing","text":"We're open to contributions and opinions!","title":"Contributing"},{"location":"#project-links","text":"Docs: https://rydra.github.io/melange","title":"Project Links"},{"location":"#license","text":"MIT licensed. See the bundled LICENSE file for more details. Logo Nature Vectors by Vecteezy","title":"License"},{"location":"advanced-topics/","text":"Advanced Topics Registering the MessagingBackend globally To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . use_backend ( SQSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.backends.sqs.backend_manager import BackendManager from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . use_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects. Message de-duplication Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a Redis cache that will control that no message is delivered twice. In order for this to work you have to provide the following environment variables as configuration so that Melange can connect to your Redis database: ENVIRONMENT VARIABLE NAME Default Description CACHE_REDIS_HOST localhost The host of your Redis CACHE_REDIS_PORT 6379 The port of your Redis CACHE_REDIS_DB 0 The DB to use for your Redis CACHE_REDIS_PASSWORD The password of your Redis CACHE_NAMESPACE SimpleCache You can provide a namespace so that values created by Melange do not collide with each other If Melange is unable to connect to your Redis it will function normally but you won't enjoy the benefits of ensuring message deduplication, which may lead your distributed application in an inconsitent state. You're warned :).","title":"Advanced topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#registering-the-messagingbackend-globally","text":"To instantiate a publishers or a consumer, you need to pass a MessagingBackend as a constructor argument. Depending on the circumstances, however, this might feel repetitive. As an alternative, you could use the singleton BackendManager and register a backend for global usage in your initialization code: BackendManager () . use_backend ( SQSBackend ()) From that point forward, any instantiation of a Publisher or Consumer does not need a backend as an argument anymore. Revisiting one of the recurring examples of this documentation, we could use the BackendManager like this. from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.backends.sqs.backend_manager import BackendManager from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () BackendManager () . use_backend ( backend ) publisher = QueuePublisher ( serializer ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Notice that we are not passing the backend now as a parameter when creating the QueuePublisher object, since it will retrieve it from the BackendManager. NOTE: Use the BackendManager with caution though. Singletons are regarded sometimes as an antipattern depending on the situation, and dependency injection is usually regarded as a cleaner solution to construct objects.","title":"Registering the MessagingBackend globally"},{"location":"advanced-topics/#message-de-duplication","text":"Distributed architectures are hard, complex and come with a good deal of burdens, but they are required to achieve levels of scalability and isolation harder to achieve on monolithic architectures. One of this issues is the possibility of of the same message being received twice by the listeners. Network failures, application crashes, etc... can cause this issue which, if not though or left undealt can cause your system to be out of sync and run in an inconsistent state. This is why you need to take measures. One of this measures is to, simply, write your listeners to be idempotent . This means that it does not matter how many times a listener is called, the result will be the same and it won't impact or leave the system into an inconsistent state. However, sometimes writing idempotent code is just not possible. You require message deduplication to account for this and ensure that a message won't be sent twice. You could use Amazon SQS FIFO Queues which they say they provide this message deduplication, though not only FIFO queues are more expensive than standard ones, but exactly-once delivery is just impossible . In Melange we have accounted for this with a Redis cache that will control that no message is delivered twice. In order for this to work you have to provide the following environment variables as configuration so that Melange can connect to your Redis database: ENVIRONMENT VARIABLE NAME Default Description CACHE_REDIS_HOST localhost The host of your Redis CACHE_REDIS_PORT 6379 The port of your Redis CACHE_REDIS_DB 0 The DB to use for your Redis CACHE_REDIS_PASSWORD The password of your Redis CACHE_NAMESPACE SimpleCache You can provide a namespace so that values created by Melange do not collide with each other If Melange is unable to connect to your Redis it will function normally but you won't enjoy the benefits of ensuring message deduplication, which may lead your distributed application in an inconsitent state. You're warned :).","title":"Message de-duplication"},{"location":"api-reference/","text":"API reference TopicPublisher Some documentation here is in order Source code in melange/message_publisher.py class TopicPublisher : \"\"\" Some documentation here is in order \"\"\" def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_backend () self . message_serializer = message_serializer def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> bool : topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish ( content , topic , event_type_name = manifest , extra_attributes = extra_attributes , ) return True MessagingBackendFactory","title":"API reference"},{"location":"api-reference/#api-reference","text":"","title":"API reference"},{"location":"api-reference/#melange.message_publisher.TopicPublisher","text":"Some documentation here is in order Source code in melange/message_publisher.py class TopicPublisher : \"\"\" Some documentation here is in order \"\"\" def __init__ ( self , message_serializer : MessageSerializer , backend : Optional [ MessagingBackend ] = None , ) -> None : self . _backend = backend or BackendManager () . get_backend () self . message_serializer = message_serializer def publish ( self , topic_name : str , data : Any , ** extra_attributes : Any ) -> bool : topic = self . _backend . declare_topic ( topic_name ) content = self . message_serializer . serialize ( data ) manifest = self . message_serializer . manifest ( data ) self . _backend . publish ( content , topic , event_type_name = manifest , extra_attributes = extra_attributes , ) return True","title":"TopicPublisher"},{"location":"api-reference/#messagingbackendfactory","text":"","title":"MessagingBackendFactory"},{"location":"factory/","text":"Factory Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform. Creating a queue Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" ) Creating a topic Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" ) For the SQSBackend this will create an SNS topic. Creating a queue and subscribing it to several topics You could create a queue and immediately subscribe it to a number of topics: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" , dead_letter_queue_name = \"payment-updates.fifo\" ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Factory"},{"location":"factory/#factory","text":"Although you could set up your own topics and queues in your infrastructure (e.g. by using terraform) you can rely on Personally I have no strong feelings over defining your queues and topics through an infrastructure-as-code framework or letting the application create it's own queues and topics (as long as it has the appropriate permissions to do so). In any case, Melange offers a factory to create queues and topics for you with the MessagingBackendFactory . The factory initialization methods are idempotent. If a queue or a topic already exist, they will keep the same queue or topic, but override any settings or customizations that you might have manually set in your PaaS platform.","title":"Factory"},{"location":"factory/#creating-a-queue","text":"Let's say you'd wish to create an Amazon SQS queue to listen to the events for a payment service. You could invoke the factory as follows: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" ) This will create a FIFO queue payment-updates in your AWS account (remember to appropriately set the AWS variables since the SQS backend uses boto behind the scenes). You could also define a dead letter queue for messages that could not be delivered successfully: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , dead_letter_queue_name = \"payment-updates.fifo\" )","title":"Creating a queue"},{"location":"factory/#creating-a-topic","text":"Topics apply the fan-out pattern to send the message to anyone who is subscribed to them. They are useful to decouple your consumers from your application so that they don't need to know who they are sending their messages to. With the factory you could create a topic like this: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_topic ( \"my-topic\" ) For the SQSBackend this will create an SNS topic.","title":"Creating a topic"},{"location":"factory/#creating-a-queue-and-subscribing-it-to-several-topics","text":"You could create a queue and immediately subscribe it to a number of topics: from melange.backends.sqs.sqs_backend import SQSBackend from melange.backends.factory import MessagingBackendFactory backend = SQSBackend () factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"payment-updates.fifo\" , \"my-topic-1\" , \"my-topic-2\" , \"my-topic-3\" , dead_letter_queue_name = \"payment-updates.fifo\" ) This will create the topics my-topic-1 , my-topic-2 and my-topic-3 , then create the payment-updates.fifo queue, and subscribe it to the aforementioned topics. It will create the dead letter queue too.","title":"Creating a queue and subscribing it to several topics"},{"location":"future-ideas/","text":"Future ideas to implement Multiple serializers Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept .","title":"Future ideas to implement"},{"location":"future-ideas/#future-ideas-to-implement","text":"","title":"Future ideas to implement"},{"location":"future-ideas/#multiple-serializers","text":"Right now, you can only supply one serializer to a publisher or a consumer, and the same serializer will always be used for all the messages published and received. This could be extended to support multiple serializers, and then let the library choose the appropriate library to use depending on the type of the message or the attached manifest. That way you could even implement serializer versioning (e.g. have different versions of the same serializer) The akka framework implements a similar concept .","title":"Multiple serializers"},{"location":"principles/","text":"Melange builds upon the concepts of Domain Driven Design. If want to have a clean event-driven architecture with Domain Events, and its idea has been grabbed from Vaughn Vernon and his must-read book Implementing Domain-Driven Design (look at part 3 of these series if you want a quick look, or read this excellent article from Udi Dahan, founder of NServiceBus ). If you wanna learn more about how to do clean architectures and domain well isolated from your technology stack I advise, again, to read Implementing Domain-Driven Design from Vaughn Vernon and Clean Architecture from Uncle Bob","title":"Principles"},{"location":"testing/","text":"Testing Any developer worth its salt does testing of some kind over the code they develop. Melange offers several utilities to help you test your publishers and consumers. The issue Testing software that spans several processes can be daunting.","title":"Testing"},{"location":"testing/#testing","text":"Any developer worth its salt does testing of some kind over the code they develop. Melange offers several utilities to help you test your publishers and consumers.","title":"Testing"},{"location":"testing/#the-issue","text":"Testing software that spans several processes can be daunting.","title":"The issue"},{"location":"components/consumers/","text":"Consumers Consumers are the counterpart of the publishers. They receive and consume the messages from a queue, and dispatch the message to a method that handles that message. To implement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method. Example","title":"Consumers"},{"location":"components/consumers/#consumers","text":"Consumers are the counterpart of the publishers. They receive and consume the messages from a queue, and dispatch the message to a method that handles that message. To implement a consumer with Melange one of the approaches is to subclass the Consumer class and implement the process method. Example","title":"Consumers"},{"location":"components/messaging-backends/","text":"Messaging backends A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The SQSBackend , the RabbitMQBackend and the ElasticMQBackend . Writing your own Messaging Backend Subclass the MessagingBackend interface and implement all the methods of that class. MessagingBackend Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> Topic : \"\"\" Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> Queue : \"\"\" Gets the queue with the name `queue_name`. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : Topic , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ Queue , Optional [ Queue ]]: \"\"\" Creates a queue named `queue_name` if it does not exist. with default settings. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : Queue , attempt_id : Optional [ str ] = None ) -> List [ Message ]: \"\"\" Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process \"\"\" raise NotImplementedError def publish ( self , content : str , topic : Topic , event_type_name : str , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes the content to the topic. The content must be a string (which is the json representation of an event) \"\"\" raise NotImplementedError def queue_publish ( self , content : str , queue : Queue , event_type_name : Optional [ str ] = None , message_group_id : Optional [ str ] = None , message_deduplication_id : Optional [ str ] = None , ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : Queue ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : Topic ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError acknowledge ( self , message ) Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError close_connection ( self ) Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass declare_queue ( self , queue_name , * topics_to_bind , * , dead_letter_queue_name = None , ** kwargs ) Creates a queue named queue_name if it does not exist. with default settings. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind Topic if provided, creates all these topics and subscribes () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to None **kwargs Any {} Returns: Type Description Tuple[melange.backends.interfaces.Queue, Optional[melange.backends.interfaces.Queue]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : Topic , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ Queue , Optional [ Queue ]]: \"\"\" Creates a queue named `queue_name` if it does not exist. with default settings. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError declare_topic ( self , topic_name ) Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> Topic : \"\"\" Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError delete_queue ( self , queue ) Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : Queue ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError delete_topic ( self , topic ) Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : Topic ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError get_queue ( self , queue_name ) Gets the queue with the name queue_name . Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description Queue A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> Queue : \"\"\" Gets the queue with the name `queue_name`. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError publish ( self , content , topic , event_type_name , extra_attributes = None ) Publishes the content to the topic. The content must be a string (which is the json representation of an event) Source code in melange/backends/interfaces.py def publish ( self , content : str , topic : Topic , event_type_name : str , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes the content to the topic. The content must be a string (which is the json representation of an event) \"\"\" raise NotImplementedError retrieve_messages ( self , queue , attempt_id = None ) Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : Queue , attempt_id : Optional [ str ] = None ) -> List [ Message ]: \"\"\" Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process \"\"\" raise NotImplementedError","title":"Messaging Backends"},{"location":"components/messaging-backends/#messaging-backends","text":"A messaging backend is a wrapper over your message broker. It exposes several methods that abstract the broker functionality, making it simpler to work with. Out of the box Melange provides you with three messaging backends: The SQSBackend , the RabbitMQBackend and the ElasticMQBackend .","title":"Messaging backends"},{"location":"components/messaging-backends/#writing-your-own-messaging-backend","text":"Subclass the MessagingBackend interface and implement all the methods of that class.","title":"Writing your own Messaging Backend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend","text":"Source code in melange/backends/interfaces.py class MessagingBackend : def __init__ ( self ) -> None : self . _finalizer = weakref . finalize ( self , self . close_connection ) def declare_topic ( self , topic_name : str ) -> Topic : \"\"\" Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError def get_queue ( self , queue_name : str ) -> Queue : \"\"\" Gets the queue with the name `queue_name`. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError def declare_queue ( self , queue_name : str , * topics_to_bind : Topic , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ Queue , Optional [ Queue ]]: \"\"\" Creates a queue named `queue_name` if it does not exist. with default settings. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError def retrieve_messages ( self , queue : Queue , attempt_id : Optional [ str ] = None ) -> List [ Message ]: \"\"\" Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process \"\"\" raise NotImplementedError def publish ( self , content : str , topic : Topic , event_type_name : str , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes the content to the topic. The content must be a string (which is the json representation of an event) \"\"\" raise NotImplementedError def queue_publish ( self , content : str , queue : Queue , event_type_name : Optional [ str ] = None , message_group_id : Optional [ str ] = None , message_deduplication_id : Optional [ str ] = None , ) -> None : raise NotImplementedError def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass def delete_queue ( self , queue : Queue ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError def delete_topic ( self , topic : Topic ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"MessagingBackend"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.acknowledge","text":"Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future Source code in melange/backends/interfaces.py def acknowledge ( self , message : Message ) -> None : \"\"\" Acknowledges a message so that it won't be redelivered by the messaging infrastructure in the future \"\"\" raise NotImplementedError","title":"acknowledge()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.close_connection","text":"Override this function if you want to use some finalizer code to shutdown your backend in a clean way Source code in melange/backends/interfaces.py def close_connection ( self ) -> None : \"\"\" Override this function if you want to use some finalizer code to shutdown your backend in a clean way \"\"\" pass","title":"close_connection()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_queue","text":"Creates a queue named queue_name if it does not exist. with default settings. Parameters: Name Type Description Default queue_name str the name of the queue to create required *topics_to_bind Topic if provided, creates all these topics and subscribes () dead_letter_queue_name Optional[str] if provided, create a dead letter queue attached to None **kwargs Any {} Returns: Type Description Tuple[melange.backends.interfaces.Queue, Optional[melange.backends.interfaces.Queue]] A tuple with the created queue and the dead letter queue (if applies) Source code in melange/backends/interfaces.py def declare_queue ( self , queue_name : str , * topics_to_bind : Topic , dead_letter_queue_name : Optional [ str ] = None , ** kwargs : Any ) -> Tuple [ Queue , Optional [ Queue ]]: \"\"\" Creates a queue named `queue_name` if it does not exist. with default settings. Args: queue_name: the name of the queue to create *topics_to_bind: if provided, creates all these topics and subscribes the created queue to them dead_letter_queue_name: if provided, create a dead letter queue attached to the created `queue_name`. **kwargs: Returns: A tuple with the created queue and the dead letter queue (if applies) \"\"\" raise NotImplementedError","title":"declare_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.declare_topic","text":"Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required Source code in melange/backends/interfaces.py def declare_topic ( self , topic_name : str ) -> Topic : \"\"\" Declares a topic exchange with the name \"topic name\" and returns an object that represent the topic :param topic_name: The name of the topic to create :return: An object that represents a topic. The type of the object is only relevant inside the context of the backend, so what you return as a topic will be passed in next calls to the backend where a topic is required \"\"\" raise NotImplementedError","title":"declare_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_queue","text":"Deletes the queue Source code in melange/backends/interfaces.py def delete_queue ( self , queue : Queue ) -> None : \"\"\" Deletes the queue \"\"\" raise NotImplementedError","title":"delete_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.delete_topic","text":"Deletes the topic Source code in melange/backends/interfaces.py def delete_topic ( self , topic : Topic ) -> None : \"\"\" Deletes the topic \"\"\" raise NotImplementedError","title":"delete_topic()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.get_queue","text":"Gets the queue with the name queue_name . Parameters: Name Type Description Default queue_name str the name of the queue to retrieve required Returns: Type Description Queue A Queue object that represents the created the queue Source code in melange/backends/interfaces.py def get_queue ( self , queue_name : str ) -> Queue : \"\"\" Gets the queue with the name `queue_name`. Args: queue_name: the name of the queue to retrieve Returns: A `Queue` object that represents the created the queue \"\"\" raise NotImplementedError","title":"get_queue()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.publish","text":"Publishes the content to the topic. The content must be a string (which is the json representation of an event) Source code in melange/backends/interfaces.py def publish ( self , content : str , topic : Topic , event_type_name : str , extra_attributes : Optional [ Dict ] = None , ) -> None : \"\"\" Publishes the content to the topic. The content must be a string (which is the json representation of an event) \"\"\" raise NotImplementedError","title":"publish()"},{"location":"components/messaging-backends/#melange.backends.interfaces.MessagingBackend.retrieve_messages","text":"Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process Source code in melange/backends/interfaces.py def retrieve_messages ( self , queue : Queue , attempt_id : Optional [ str ] = None ) -> List [ Message ]: \"\"\" Returns a list of messages (instances of Message type) that have been received from the queue. :param queue: queue to poll :return: a list of messages to process \"\"\" raise NotImplementedError","title":"retrieve_messages()"},{"location":"components/publishers/","text":"Publishers Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics. Publishing to a queue Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application Publishing to a topic Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.message_publisher import TopicPublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishers"},{"location":"components/publishers/#publishers","text":"Publishers, as implied by the name, publish messages to a message broker, which are then propagated/stored into a queue for consumers/subscribers to process. You can publish messages to queues or topics.","title":"Publishers"},{"location":"components/publishers/#publishing-to-a-queue","text":"Publishing a message to a queue makes this message available to a single consumer (that's the concept of a queue after all). To do that, build an instance of the QueuePublisher class and call the publish method with your message: from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) The QueuePublisher requires a backend and a serializer as constructor parameters. The serializer is necessary to properly serialize and send the message to the messaging backend. TIP: In a production project where you would have a proper dependency injection framework in place (e.g. pinject ), you could instantiate the Publisher once and provide that instance through your application","title":"Publishing to a queue"},{"location":"components/publishers/#publishing-to-a-topic","text":"Publishing a message to a topic works exactly the same way as publishing to a queue, but it will work with the Fanout pattern to distribute the message to several subscribers of that topic. To do that, build an instance of the TopicPublisher class and call the publish method with your message: from melange.message_publisher import TopicPublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = TopicPublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-topic\" , message ) print ( \"Message sent successfully!\" ) As you can appreciate it works exactly the same way as publishing to a queue, the only difference happens behind the scenes.","title":"Publishing to a topic"},{"location":"components/serializers/","text":"Serializers Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list Creating your own serializers To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface: MessageSerializer ( Generic ) Base interface to inherit for all the serializers of the platform Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers of the platform \"\"\" def manifest ( self , data : T ) -> str : return \"\" def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation \"\"\" pass serialize ( self , data ) Serializes and object to a string representation Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation \"\"\" pass Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"Serializers"},{"location":"components/serializers/#serializers","text":"Serializers are the component that translates (serializes) your python objects into a string that can be sent through the messaging infrastructure, and then translates it (deserializes) that string back to the python object. Melange is bundled with two serializers: a JSONSerializer to serialize python dictionaries and a PickleSerializer that will serialize any python object, but will only be deserializable from another python process and it's generally regarded as unsafe). When instantiating a publisher or a consumer you need to pass a list of serializers. Melange, upon sending or receiving messages, will select the serializer that best matches the one that can serialize and deserialize it. TODO: Implement the serializer selector from a list","title":"Serializers"},{"location":"components/serializers/#creating-your-own-serializers","text":"To create your own serializer, you need to inherit the class MessageSerializer and implement the methods manifest , deserialize and serialize . This is the MessageSerializer interface:","title":"Creating your own serializers"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer","text":"Base interface to inherit for all the serializers of the platform Source code in melange/serializers/interfaces.py class MessageSerializer ( Generic [ T ]): \"\"\" Base interface to inherit for all the serializers of the platform \"\"\" def manifest ( self , data : T ) -> str : return \"\" def deserialize ( self , data : str , manifest : Optional [ str ] = None ) -> T : pass def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation \"\"\" pass","title":"MessageSerializer"},{"location":"components/serializers/#melange.serializers.interfaces.MessageSerializer.serialize","text":"Serializes and object to a string representation Source code in melange/serializers/interfaces.py def serialize ( self , data : T ) -> str : \"\"\" Serializes and object to a string representation \"\"\" pass Some ideas of custom serializers: A protocol buffer serializer: Protocol Buffers (or protobuf for short) is a fast and compact serializing technology. In some projects where Melange is used in production such serializer has been implemented successfully.","title":"serialize()"},{"location":"examples/payment-service/","text":"Payment Service TODO","title":"Payment service"},{"location":"examples/payment-service/#payment-service","text":"TODO","title":"Payment Service"},{"location":"examples/saga/","text":"Saga TODO","title":"Saga choreography"},{"location":"examples/saga/#saga","text":"TODO","title":"Saga"},{"location":"tutorial/getting-started/","text":"Tutorial - Getting started Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker. Choosing a Messaging Backend A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use ElasticMQ as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with an SQS-like infrastructure to use with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the ElasticMQ project to install it to your local machine. Though the quickest route is to launch the docker image: docker run -p 9324:9324 -p 9325:9325 softwaremill/elasticmq-native This will start ElasticMQ in the port 9324 in localhost , ready to be used. Creating a queue Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.backends.factory import MessagingBackendFactory backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" ) Publishing messages Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers. Consuming messages It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.consumers import Consumer , ConsumerHandler from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer from publish_example import MyTestMessage class MyConsumer ( SingleDispatchConsumer ): @listener def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () consumer_handler = SimpleConsumerHandler ( serializer , backend = backend , ) print ( \"Consuming...\" ) payment_consumer . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py ) Where to go from here Although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#tutorial-getting-started","text":"Event-driven architectures work with the Publish/Subscribe pattern to achieve decoupling. With this pattern, publishers and subscribers do not know about each other while they can exchange information among them. In order to achieve this and communicate effectively a mediator, or better said, a Message Broker is required to transfer messages from publishers to subscribers. Clients can subscribe this broker, waiting for events they are interested in, or publish messages so that the broker can distribute these messages appropriately. This tutorial assumes that you have basic understanding of the pub/sub mechanics. If not, there are a whole bunch of resources to get your feet wet on the topic. Also it's good to have docker installed since we are going to spin up local infrastructure to serve as a messaging broker.","title":"Tutorial - Getting started"},{"location":"tutorial/getting-started/#choosing-a-messaging-backend","text":"A messaging backend is the infrastructure where your messages are going to be published and consumed. In this tutorial we are going to use ElasticMQ as our messaging backend. Basically spinning up an ElasticMQ (for example with docker-compose ) in your machine will provide you with an SQS-like infrastructure to use with boto, which makes it ideal for testing and for the sake of this tutorial. You could follow the instructions in the ElasticMQ project to install it to your local machine. Though the quickest route is to launch the docker image: docker run -p 9324:9324 -p 9325:9325 softwaremill/elasticmq-native This will start ElasticMQ in the port 9324 in localhost , ready to be used.","title":"Choosing a Messaging Backend"},{"location":"tutorial/getting-started/#creating-a-queue","text":"Before using a queue you need to create it. Put the following code snippet into a file called create_queue.py and execute it to create the queue: from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.backends.factory import MessagingBackendFactory backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) factory = MessagingBackendFactory ( backend ) factory . init_queue ( \"melangetutorial-queue\" )","title":"Creating a queue"},{"location":"tutorial/getting-started/#publishing-messages","text":"Publishing messages to a queue with Melange is easy. Just create an instance of the message publisher and publish the message. Put the following code snippet into a file called publish_example.py : from melange.message_publisher import QueuePublisher from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer class MyTestMessage : def __init__ ( self , message : str ) -> None : self . message = message if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () publisher = QueuePublisher ( serializer , backend ) message = MyTestMessage ( \"Hello World!\" ) publisher . publish ( \"melangetutorial-queue\" , message ) print ( \"Message sent successfully!\" ) Once you run this code it will publish a message MyTestMessage with the contents Hello World in the queue melangetutorial-queue . You can send anything as long as your selected serializer can serialize/deserialize the object. Refer Serializers for further details. NOTE: For the sake of this tutorial you can use the PickleSerializer to serialize your messages. For production applications however you should probably use another type of serializer or create your own, since pickle is considered unsafe and only works with python consumers.","title":"Publishing messages"},{"location":"tutorial/getting-started/#consuming-messages","text":"It's good to publish messages, but they are worth nothing if nobody reads them. Therefore, we need a consumer that reads these messages and reacts to them. Put the following code snippet in a file called consumer-example.py and run it: from melange.consumers import Consumer , ConsumerHandler from melange.backends.sqs.elasticmq import ElasticMQBackend from melange.serializers.pickle import PickleSerializer from publish_example import MyTestMessage class MyConsumer ( SingleDispatchConsumer ): @listener def on_my_test_message_received ( self , event : MyTestMessage ) -> None : print ( event . message ) if __name__ == \"__main__\" : backend = ElasticMQBackend ( host = \"localhost\" , port = 9324 ) serializer = PickleSerializer () consumer = MyConsumer () consumer_handler = SimpleConsumerHandler ( serializer , backend = backend , ) print ( \"Consuming...\" ) payment_consumer . consume_loop ( \"melangetutorial-queue\" ) Upon hitting the consume_loop method, the process will start polling the queue for new messages. Once it receives a message, as long as the message is of type MyTestMessage it will forward this message to the MyConsumer . If your infrastructure was set correctly, every time you run the publish_example.py script you will see a print with the message on the screen where the consumer is running. Congratulations! You just run your very first example of a Pub/Sub mechanism with Melange! NOTE: It's a good idea to have shared classes (like the MyTestMessage in the example) in its own python module (e.g. shared.py )","title":"Consuming messages"},{"location":"tutorial/getting-started/#where-to-go-from-here","text":"Although the exposed example is quite simple, it serves as the foundation to implement a number of use cases and distributed architectures with microservices. With Melange you can: Build a CQRS + Event sourcing architecture, where you publish your events to a queue or topic from the Command side and read those with a consumer from the Read side to create your data projections. Build choreography Sagas for long-running processes which can span several transactions. Implement microservices which consume messages from a queue to do their job (e.g. an staticstics microservice that reacts to a OrderCreated event and increments a counter to track how many orders your system has). We have not covered the case of topics. Refer to Publishers for further details. In addition, Melange is bundled with a consumer that works with a python application. But the consumer can be implemented in any language and any technology that can read messages from your queue (AWS Lambda, Azure functions, a NodeJS app...)","title":"Where to go from here"}]}